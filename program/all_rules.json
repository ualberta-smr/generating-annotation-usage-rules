[
    {
      "id": 1,
      "antecedent": [
        "Method --(annotatedWith)--> Annotation_javax.annotation.security.RolesAllowed"
      ],
      "consequent": [
        "Class --(annotatedWith)--> Annotation_org.eclipse.microprofile.auth.LoginConfig",
        "Class --(extends/implements)--> Application"
      ],
      "label": "correct",
      "comment": "Not supported. The rule is not captured because @RolesAllowed annotates some resource class's method, while @LoginConfig annotates main (driver) class which is completely different and located elsewhere."
    },
    {
      "id": 2,
      "antecedent": [
        "Method --(annotatedWith)--> Annotation_org.eclipse.microprofile.faulttolerance.Fallback"
      ],
      "consequent": [
        "Annotation_org.eclipse.microprofile.faulttolerance.Fallback --(hasParam)--> Param_fallbackMethod:java.lang.String|value:java.lang.Class"
      ],
      "label": "correct",
      "comment": "Supported. this rule is fully captured, though there are less usages of `.Class`"
    },
    {
      "id": 3,
      "antecedent": [
        "Method --(annotatedWith)--> Annotation_org.eclipse.microprofile.faulttolerance.Bulkhead",
        "Annotation_org.eclipse.microprofile.faulttolerance.Bulkhead --(hasParam)--> Param_waitingTaskQueue:int"
      ],
      "consequent": [
        "Method --(annotatedWith)--> Annotation_org.eclipse.microprofile.faulttolerance.Asynchronous"
      ],
      "label": "correct",
      "comment": "Not enough usages. This rule is not captured because there are little usages. There are usages of Bulkhead in test directory in Payara and helidon, however since test code does not represent a real usage scenario, we ignore all `src/test` directories of all projects."
    },
    {
      "id": 4,
      "antecedent": [
        "Method --(annotatedWith)--> Annotation_org.eclipse.microprofile.faulttolerance.Asynchronous"
      ],
      "consequent": [
        "Method --(hasReturnType)--> java.util.concurrent.CompletionStage|java.util.concurrent.Future"
      ],
      "label": "correct",
      "comment": "Supported. This rule is captured."
    },
    {
      "id": 5,
      "antecedent": [
        "Method --(annotatedWith)--> Annotation_org.eclipse.microprofile.faulttolerance.*",
        "Method --(annotatedWith)--> Annotation_org.eclipse.microprofile.faulttolerance.Asynchronous"
      ],
      "consequent": [
        "Method --(hasReturnType)--> java.util.concurrent.CompletionStage"
      ],
      "label": "correct",
      "comment": "Supported. This rule is captured."
    },
    {
      "id": 6,
      "antecedent": [
        "Method --(methodOf)--> Class_A",
        "Method --(returns)--> TypeY",
        "Method --(hasParamList)--> {Type1,Type2,Type3}",
        "Method --(annWith)--> Annotation_org.eclipse.microprofile.faulttolerance.Fallback",
        "Annotation_org.eclipse.microprofile.faulttolerance.Fallback --(hasParam)--> Param_fallbackMethod:java.lang.String",
        "Param_fallbackMethod:java.lang.String --(hasValue)--> X"
      ],
      "consequent": [
        "X --(methodOf)--> Class_A | Super(Class_A)",
        "X --(returns)--> TypeY",
        "X --(hasParamList)--> {Type1,Type2,Type3}"
      ],
      "label": "correct",
      "comment": "Not supported (we don't check if a value of some parameter is another method that adheres to these requirements)"
    },
    {
      "id": 7,
      "antecedent": [
        "Field --(annotatedWith)--> Annotation_org.eclipse.microprofile.config.inject.ConfigProperty",
        "Annotation_org.eclipse.microprofile.config.inject.ConfigProperty --(hasParam)--> Param_name:java.lang.String"
      ],
      "consequent": [
        "Param_name:java.lang.String --(definedIn)--> ConfigFile_microprofile-config.properties OR `value` must be defined in other ConfigSource."
      ],
      "label": "correct",
      "comment": "Supported. We capture this rule partially (we have partially correct candidate rules) because there are other multiple configuration sources."
    },
    {
      "id": 8,
      "antecedent": [
        "(If) Implementing RestClientBuilder"
      ],
      "consequent": [
        "(Then) Implement RestClientBuilderResolver and provide the implementation of RestClientBuilder in method `newBuilder()`."
      ],
      "label": "correct",
      "comment": "Not supported. We do not analyze method bodies."
    },
    {
      "id": 9,
      "antecedent": [
        "(If) Using ClientBuilder"
      ],
      "consequent": [
        "(Then) Must call ClientTracingRegistrar.configure(ClientBuilder) to enable tracing"
      ],
      "label": "correct",
      "comment": "Not supported. We do not analyze method bodies."
    },
    {
      "id": 10,
      "antecedent": [
        "Method --(annotatedWith)--> Annotation_org.eclipse.microprofile.reactive.messaging.Outgoing|Annotation_org.eclipse.microprofile.reactive.messaging.Incoming"
      ],
      "consequent": [
        "Class --(annotatedWith)--> Annotation_javax.enterprise.context.ApplicationScoped|Annotation_javax.enterprise.context.Dependent"
      ],
      "label": "correct",
      "comment": "Supported. The rule is captured."
    },
    {
      "id": 11,
      "antecedent": [
        "Method --(annotatedWith)--> Annotation_org.eclipse.microprofile.openapi.annotations.Operation"
      ],
      "consequent": [
        "Method|Class --(annotatedWith)--> Annotation_javax.ws.rs.Path"
      ],
      "label": "correct",
      "comment": "Supported. The rule is captured, though sometimes it only captures `Method` or `Class` for @Path, but not together."
    },
    {
      "id": 12,
      "antecedent": [
        "Method --(annotatedWith)--> Annotation_org.eclipse.microprofile.openapi.annotations.Operation"
      ],
      "consequent": [
        "Method --(hasReturnType)--> javax.ws.rs.core.Response"
      ],
      "label": "correct",
      "comment": "Supported. The rule is captured."
    },
    {
      "id": 13,
      "antecedent": [
        "Class --(annotatedWith)--> Annotation_org.eclipse.microprofile.openapi.annotations.tags.Tag"
      ],
      "consequent": [
        "Method|Class --(annotatedWith)--> Annotation_javax.ws.rs.Path"
      ],
      "label": "correct",
      "comment": "Supported. The rule is captured, though sometimes it only captures `Method` or `Class` for @Path, but not together."
    },
    {
      "id": 14,
      "antecedent": [
        "Class --(annotatedWith)--> Annotation_org.eclipse.microprofile.rest.client.inject.RegisterRestClient"
      ],
      "consequent": [
        "Method|Class --(annotatedWith)--> Annotation_javax.ws.rs.Path"
      ],
      "label": "correct",
      "comment": "Supported. The rule is captured, though sometimes it only captures `Method` or `Class` for @Path, but not together."
    },
    {
      "id": 15,
      "antecedent": [
        "Class --(annotatedWith)--> Annotation_org.eclipse.microprofile.health.Liveness"
      ],
      "consequent": [
        "Class --(extends/implements)--> Class_org.eclipse.microprofile.health.HealthCheck"
      ],
      "label": "correct",
      "comment": "Supported. The rule is captured."
    },
    {
      "id": 16,
      "antecedent": [
        "Class --(annotatedWith)--> @org.eclipse.microprofile.health.Readiness"
      ],
      "consequent": [
        "Class --(extends/implements)--> Class_org.eclipse.microprofile.health.HealthCheck"
      ],
      "label": "correct",
      "comment": "Supported. The rule is captured."
    },
    {
      "id": 17,
      "antecedent": [
        "Class --(annotatedWith)--> @org.eclipse.microprofile.health.Health"
      ],
      "consequent": [
        "Class --(extends/implements)--> Class_org.eclipse.microprofile.health.HealthCheck"
      ],
      "label": "correct",
      "comment": "Supported. The rule is captured, though deprecated. We can still mine potential rule templates like that."
    },
    {
      "id": 18,
      "antecedent": [
        "Field --(annotatedWith)--> Annotation_org.eclipse.microprofile.jwt.Claim"
      ],
      "consequent": [
        "Field --(annotatedWith)--> Annotation_javax.inject.Inject"
      ],
      "label": "correct",
      "comment": "Supported. The rule is captured."
    },
    {
      "id": 19,
      "antecedent": [
        "Field --(annotatedWith)--> Annotation_org.eclipse.microprofile.rest.client.inject.RestClient"
      ],
      "consequent": [
        "Field --(annotatedWith)--> Annotation_javax.inject.Inject"
      ],
      "label": "correct",
      "comment": "Supported. The rule is captured."
    },
    {
      "id": 20,
      "antecedent": [
        "Field --(hasType)--> org.eclipse.microprofile.jwt.JsonWebToken"
      ],
      "consequent": [
        "Field --(annotatedWith)--> Annotation_javax.inject.Inject"
      ],
      "label": "correct",
      "comment": "Supported. The rule is captured."
    },
    {
      "id": 21,
      "antecedent": [
        "Class|Method --(annotatedWith)--> Annotation_javax.ws.rs.Produces|Consumes|GET|POST|PUT|DELETE|UPDATE"
      ],
      "consequent": [
        "Class|Method --(annotatedWith)--> Annotation_javax.ws.rs.Path"
      ],
      "label": "correct",
      "comment": "Supported. The rule is captured, though sometimes it only captures `Method` or `Class` for @Path, but not together."
    },
    {
        "id": 22,
        "antecedent": [
        "Param_Type --(annotatedWith)--> Annotation_javax.ws.rs.PathParam"
        ],
        "consequent": [
        "Class|Method --(annotatedWith)--> Annotation_javax.ws.rs.Path"
        ],
        "label": "correct",
        "comment": "Supported. The rule is captured, though sometimes it only captures `Method` or `Class` for @Path, but not together."
    },
    {
      "id": 23,
      "antecedent": [
        "Method --(annotatedWith)--> Annotation_org.eclipse.microprofile.graphql.Mutation|Query"
      ],
      "consequent": [
        "Class --(annotatedWith)--> Annotation_org.eclipse.microprofile.graphql.GraphQLApi"
      ],
      "label": "correct",
      "comment": "Supported. The rule is captured, though sometimes it only captures `Method` or `Class` for @Path, but not together."
    }
  ]