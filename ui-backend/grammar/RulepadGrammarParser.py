# Generated from RulepadGrammar.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3-")
        buf.write("\u02e5\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\3\2\7\2\u008e\n\2\f\2\16\2\u0091\13\2\3")
        buf.write("\2\5\2\u0094\n\2\3\2\5\2\u0097\n\2\3\2\7\2\u009a\n\2\f")
        buf.write("\2\16\2\u009d\13\2\3\2\3\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\5\3\u00c4\n\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\7\4\u00cd")
        buf.write("\n\4\f\4\16\4\u00d0\13\4\3\4\3\4\3\4\3\5\6\5\u00d6\n\5")
        buf.write("\r\5\16\5\u00d7\3\5\3\5\6\5\u00dc\n\5\r\5\16\5\u00dd\3")
        buf.write("\5\3\5\6\5\u00e2\n\5\r\5\16\5\u00e3\3\5\3\5\6\5\u00e8")
        buf.write("\n\5\r\5\16\5\u00e9\3\5\6\5\u00ed\n\5\r\5\16\5\u00ee\3")
        buf.write("\5\3\5\3\5\6\5\u00f4\n\5\r\5\16\5\u00f5\3\5\3\5\3\5\6")
        buf.write("\5\u00fb\n\5\r\5\16\5\u00fc\3\5\3\5\3\5\6\5\u0102\n\5")
        buf.write("\r\5\16\5\u0103\3\5\5\5\u0107\n\5\3\6\3\6\3\6\3\6\6\6")
        buf.write("\u010d\n\6\r\6\16\6\u010e\3\6\3\6\3\7\3\7\3\b\3\b\3\t")
        buf.write("\3\t\3\n\3\n\3\n\3\n\6\n\u011d\n\n\r\n\16\n\u011e\3\n")
        buf.write("\3\n\3\13\3\13\3\f\3\f\3\r\3\r\3\16\3\16\3\17\3\17\3\20")
        buf.write("\3\20\3\21\3\21\5\21\u0131\n\21\3\22\3\22\5\22\u0135\n")
        buf.write("\22\3\23\3\23\3\23\3\24\3\24\5\24\u013c\n\24\3\25\3\25")
        buf.write("\3\25\5\25\u0141\n\25\3\25\5\25\u0144\n\25\3\26\3\26\3")
        buf.write("\26\3\27\3\27\3\27\3\27\3\27\3\27\5\27\u014f\n\27\3\27")
        buf.write("\3\27\3\27\3\27\3\27\3\27\7\27\u0157\n\27\f\27\16\27\u015a")
        buf.write("\13\27\3\30\3\30\3\30\3\31\3\31\3\31\3\31\3\31\5\31\u0164")
        buf.write("\n\31\3\32\3\32\3\32\3\33\3\33\3\33\3\33\3\33\5\33\u016e")
        buf.write("\n\33\3\34\3\34\5\34\u0172\n\34\3\34\5\34\u0175\n\34\3")
        buf.write("\35\3\35\3\35\3\36\3\36\3\36\3\37\3\37\3\37\3\37\3\37")
        buf.write("\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37\5\37")
        buf.write("\u018c\n\37\5\37\u018e\n\37\3\37\3\37\3\37\3\37\3\37\3")
        buf.write("\37\7\37\u0196\n\37\f\37\16\37\u0199\13\37\3 \3 \5 \u019d")
        buf.write("\n \3 \5 \u01a0\n \3!\3!\3!\3\"\3\"\3\"\3#\3#\3#\3#\3")
        buf.write("#\3#\3#\3#\3#\3#\3#\5#\u01b3\n#\5#\u01b5\n#\3#\3#\3#\3")
        buf.write("#\3#\3#\7#\u01bd\n#\f#\16#\u01c0\13#\3$\3$\5$\u01c4\n")
        buf.write("$\3$\5$\u01c7\n$\3%\3%\3%\3&\3&\3&\3\'\3\'\3\'\3\'\3\'")
        buf.write("\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\5\'\u01dc\n\'\5\'\u01de")
        buf.write("\n\'\3\'\3\'\3\'\3\'\3\'\3\'\7\'\u01e6\n\'\f\'\16\'\u01e9")
        buf.write("\13\'\3(\3(\5(\u01ed\n(\3)\3)\3)\3*\3*\3*\3*\3*\3*\3*")
        buf.write("\5*\u01f9\n*\5*\u01fb\n*\3*\3*\3*\3*\3*\3*\7*\u0203\n")
        buf.write("*\f*\16*\u0206\13*\3+\3+\5+\u020a\n+\3,\3,\3,\3,\3,\3")
        buf.write(",\5,\u0212\n,\3-\3-\5-\u0216\n-\3.\3.\3.\3/\3/\5/\u021d")
        buf.write("\n/\3\60\3\60\3\60\3\61\3\61\5\61\u0224\n\61\3\62\3\62")
        buf.write("\3\62\3\63\3\63\5\63\u022b\n\63\3\63\5\63\u022e\n\63\3")
        buf.write("\64\3\64\3\64\3\64\5\64\u0234\n\64\3\65\3\65\3\65\3\66")
        buf.write("\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66")
        buf.write("\5\66\u0245\n\66\5\66\u0247\n\66\3\66\3\66\3\66\3\66\3")
        buf.write("\66\3\66\7\66\u024f\n\66\f\66\16\66\u0252\13\66\3\67\3")
        buf.write("\67\5\67\u0256\n\67\3\67\5\67\u0259\n\67\38\38\38\38\5")
        buf.write("8\u025f\n8\39\39\39\3:\3:\3:\3:\3:\3:\3:\5:\u026b\n:\5")
        buf.write(":\u026d\n:\3:\3:\3:\3:\3:\3:\7:\u0275\n:\f:\16:\u0278")
        buf.write("\13:\3;\3;\5;\u027c\n;\3<\3<\3<\3=\3=\5=\u0283\n=\3=\5")
        buf.write("=\u0286\n=\3>\3>\3>\3?\3?\3?\3@\3@\5@\u0290\n@\3A\3A\3")
        buf.write("A\3B\3B\3B\3B\3B\3B\3B\3B\3B\3B\3B\3B\3B\3B\3B\3B\3B\3")
        buf.write("B\5B\u02a7\nB\5B\u02a9\nB\3B\3B\3B\3B\3B\3B\7B\u02b1\n")
        buf.write("B\fB\16B\u02b4\13B\3C\3C\5C\u02b8\nC\3C\5C\u02bb\nC\3")
        buf.write("D\3D\3D\3E\3E\3E\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3")
        buf.write("F\3F\3F\3F\3F\3F\3F\5F\u02d6\nF\5F\u02d8\nF\3F\3F\3F\3")
        buf.write("F\3F\3F\7F\u02e0\nF\fF\16F\u02e3\13F\3F\2\13,<DLRjr\u0082")
        buf.write("\u008aG\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*")
        buf.write(",.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080")
        buf.write("\u0082\u0084\u0086\u0088\u008a\2\3\4\2\t\16\30\31\2\u0332")
        buf.write("\2\u0093\3\2\2\2\4\u00c3\3\2\2\2\6\u00c5\3\2\2\2\b\u0106")
        buf.write("\3\2\2\2\n\u0108\3\2\2\2\f\u0112\3\2\2\2\16\u0114\3\2")
        buf.write("\2\2\20\u0116\3\2\2\2\22\u0118\3\2\2\2\24\u0122\3\2\2")
        buf.write("\2\26\u0124\3\2\2\2\30\u0126\3\2\2\2\32\u0128\3\2\2\2")
        buf.write("\34\u012a\3\2\2\2\36\u012c\3\2\2\2 \u0130\3\2\2\2\"\u0132")
        buf.write("\3\2\2\2$\u0136\3\2\2\2&\u0139\3\2\2\2(\u0143\3\2\2\2")
        buf.write("*\u0145\3\2\2\2,\u014e\3\2\2\2.\u015b\3\2\2\2\60\u015e")
        buf.write("\3\2\2\2\62\u0165\3\2\2\2\64\u0168\3\2\2\2\66\u016f\3")
        buf.write("\2\2\28\u0176\3\2\2\2:\u0179\3\2\2\2<\u018d\3\2\2\2>\u019a")
        buf.write("\3\2\2\2@\u01a1\3\2\2\2B\u01a4\3\2\2\2D\u01b4\3\2\2\2")
        buf.write("F\u01c1\3\2\2\2H\u01c8\3\2\2\2J\u01cb\3\2\2\2L\u01dd\3")
        buf.write("\2\2\2N\u01ea\3\2\2\2P\u01ee\3\2\2\2R\u01fa\3\2\2\2T\u0207")
        buf.write("\3\2\2\2V\u0211\3\2\2\2X\u0213\3\2\2\2Z\u0217\3\2\2\2")
        buf.write("\\\u021a\3\2\2\2^\u021e\3\2\2\2`\u0221\3\2\2\2b\u0225")
        buf.write("\3\2\2\2d\u0228\3\2\2\2f\u022f\3\2\2\2h\u0235\3\2\2\2")
        buf.write("j\u0246\3\2\2\2l\u0253\3\2\2\2n\u025a\3\2\2\2p\u0260\3")
        buf.write("\2\2\2r\u026c\3\2\2\2t\u0279\3\2\2\2v\u027d\3\2\2\2x\u0280")
        buf.write("\3\2\2\2z\u0287\3\2\2\2|\u028a\3\2\2\2~\u028d\3\2\2\2")
        buf.write("\u0080\u0291\3\2\2\2\u0082\u02a8\3\2\2\2\u0084\u02b5\3")
        buf.write("\2\2\2\u0086\u02bc\3\2\2\2\u0088\u02bf\3\2\2\2\u008a\u02d7")
        buf.write("\3\2\2\2\u008c\u008e\5\20\t\2\u008d\u008c\3\2\2\2\u008e")
        buf.write("\u0091\3\2\2\2\u008f\u008d\3\2\2\2\u008f\u0090\3\2\2\2")
        buf.write("\u0090\u0094\3\2\2\2\u0091\u008f\3\2\2\2\u0092\u0094\5")
        buf.write("\4\3\2\u0093\u008f\3\2\2\2\u0093\u0092\3\2\2\2\u0094\u0096")
        buf.write("\3\2\2\2\u0095\u0097\5\16\b\2\u0096\u0095\3\2\2\2\u0096")
        buf.write("\u0097\3\2\2\2\u0097\u009b\3\2\2\2\u0098\u009a\7\27\2")
        buf.write("\2\u0099\u0098\3\2\2\2\u009a\u009d\3\2\2\2\u009b\u0099")
        buf.write("\3\2\2\2\u009b\u009c\3\2\2\2\u009c\u009e\3\2\2\2\u009d")
        buf.write("\u009b\3\2\2\2\u009e\u009f\7\2\2\3\u009f\3\3\2\2\2\u00a0")
        buf.write("\u00a1\5\66\34\2\u00a1\u00a2\5\24\13\2\u00a2\u00a3\5\34")
        buf.write("\17\2\u00a3\u00a4\5<\37\2\u00a4\u00c4\3\2\2\2\u00a5\u00a6")
        buf.write("\5> \2\u00a6\u00a7\5\24\13\2\u00a7\u00a8\5\34\17\2\u00a8")
        buf.write("\u00a9\5D#\2\u00a9\u00c4\3\2\2\2\u00aa\u00ab\5F$\2\u00ab")
        buf.write("\u00ac\5\24\13\2\u00ac\u00ad\5\34\17\2\u00ad\u00ae\5L")
        buf.write("\'\2\u00ae\u00c4\3\2\2\2\u00af\u00b0\5~@\2\u00b0\u00b1")
        buf.write("\5\24\13\2\u00b1\u00b2\5\34\17\2\u00b2\u00b3\5\u0082B")
        buf.write("\2\u00b3\u00c4\3\2\2\2\u00b4\u00b5\5N(\2\u00b5\u00b6\5")
        buf.write("\24\13\2\u00b6\u00b7\5\34\17\2\u00b7\u00b8\5R*\2\u00b8")
        buf.write("\u00c4\3\2\2\2\u00b9\u00ba\5d\63\2\u00ba\u00bb\5\24\13")
        buf.write("\2\u00bb\u00bc\5\34\17\2\u00bc\u00bd\5j\66\2\u00bd\u00c4")
        buf.write("\3\2\2\2\u00be\u00bf\5\u0084C\2\u00bf\u00c0\5\24\13\2")
        buf.write("\u00c0\u00c1\5\34\17\2\u00c1\u00c2\5\u008aF\2\u00c2\u00c4")
        buf.write("\3\2\2\2\u00c3\u00a0\3\2\2\2\u00c3\u00a5\3\2\2\2\u00c3")
        buf.write("\u00aa\3\2\2\2\u00c3\u00af\3\2\2\2\u00c3\u00b4\3\2\2\2")
        buf.write("\u00c3\u00b9\3\2\2\2\u00c3\u00be\3\2\2\2\u00c4\5\3\2\2")
        buf.write("\2\u00c5\u00ce\7\3\2\2\u00c6\u00c7\5\b\5\2\u00c7\u00c8")
        buf.write("\7\4\2\2\u00c8\u00cd\3\2\2\2\u00c9\u00ca\5\b\5\2\u00ca")
        buf.write("\u00cb\7\5\2\2\u00cb\u00cd\3\2\2\2\u00cc\u00c6\3\2\2\2")
        buf.write("\u00cc\u00c9\3\2\2\2\u00cd\u00d0\3\2\2\2\u00ce\u00cc\3")
        buf.write("\2\2\2\u00ce\u00cf\3\2\2\2\u00cf\u00d1\3\2\2\2\u00d0\u00ce")
        buf.write("\3\2\2\2\u00d1\u00d2\5\b\5\2\u00d2\u00d3\7\3\2\2\u00d3")
        buf.write("\7\3\2\2\2\u00d4\u00d6\7\26\2\2\u00d5\u00d4\3\2\2\2\u00d6")
        buf.write("\u00d7\3\2\2\2\u00d7\u00d5\3\2\2\2\u00d7\u00d8\3\2\2\2")
        buf.write("\u00d8\u0107\3\2\2\2\u00d9\u00db\7\6\2\2\u00da\u00dc\7")
        buf.write("\26\2\2\u00db\u00da\3\2\2\2\u00dc\u00dd\3\2\2\2\u00dd")
        buf.write("\u00db\3\2\2\2\u00dd\u00de\3\2\2\2\u00de\u0107\3\2\2\2")
        buf.write("\u00df\u00e1\7\7\2\2\u00e0\u00e2\7\26\2\2\u00e1\u00e0")
        buf.write("\3\2\2\2\u00e2\u00e3\3\2\2\2\u00e3\u00e1\3\2\2\2\u00e3")
        buf.write("\u00e4\3\2\2\2\u00e4\u0107\3\2\2\2\u00e5\u00e7\7\b\2\2")
        buf.write("\u00e6\u00e8\7\26\2\2\u00e7\u00e6\3\2\2\2\u00e8\u00e9")
        buf.write("\3\2\2\2\u00e9\u00e7\3\2\2\2\u00e9\u00ea\3\2\2\2\u00ea")
        buf.write("\u0107\3\2\2\2\u00eb\u00ed\7\26\2\2\u00ec\u00eb\3\2\2")
        buf.write("\2\u00ed\u00ee\3\2\2\2\u00ee\u00ec\3\2\2\2\u00ee\u00ef")
        buf.write("\3\2\2\2\u00ef\u00f0\3\2\2\2\u00f0\u0107\7\7\2\2\u00f1")
        buf.write("\u00f3\7\6\2\2\u00f2\u00f4\7\26\2\2\u00f3\u00f2\3\2\2")
        buf.write("\2\u00f4\u00f5\3\2\2\2\u00f5\u00f3\3\2\2\2\u00f5\u00f6")
        buf.write("\3\2\2\2\u00f6\u00f7\3\2\2\2\u00f7\u0107\7\7\2\2\u00f8")
        buf.write("\u00fa\7\7\2\2\u00f9\u00fb\7\26\2\2\u00fa\u00f9\3\2\2")
        buf.write("\2\u00fb\u00fc\3\2\2\2\u00fc\u00fa\3\2\2\2\u00fc\u00fd")
        buf.write("\3\2\2\2\u00fd\u00fe\3\2\2\2\u00fe\u0107\7\7\2\2\u00ff")
        buf.write("\u0101\7\b\2\2\u0100\u0102\7\26\2\2\u0101\u0100\3\2\2")
        buf.write("\2\u0102\u0103\3\2\2\2\u0103\u0101\3\2\2\2\u0103\u0104")
        buf.write("\3\2\2\2\u0104\u0105\3\2\2\2\u0105\u0107\7\7\2\2\u0106")
        buf.write("\u00d5\3\2\2\2\u0106\u00d9\3\2\2\2\u0106\u00df\3\2\2\2")
        buf.write("\u0106\u00e5\3\2\2\2\u0106\u00ec\3\2\2\2\u0106\u00f1\3")
        buf.write("\2\2\2\u0106\u00f8\3\2\2\2\u0106\u00ff\3\2\2\2\u0107\t")
        buf.write("\3\2\2\2\u0108\u010c\7\3\2\2\u0109\u010d\7\26\2\2\u010a")
        buf.write("\u010d\5\f\7\2\u010b\u010d\7\25\2\2\u010c\u0109\3\2\2")
        buf.write("\2\u010c\u010a\3\2\2\2\u010c\u010b\3\2\2\2\u010d\u010e")
        buf.write("\3\2\2\2\u010e\u010c\3\2\2\2\u010e\u010f\3\2\2\2\u010f")
        buf.write("\u0110\3\2\2\2\u0110\u0111\7\3\2\2\u0111\13\3\2\2\2\u0112")
        buf.write("\u0113\t\2\2\2\u0113\r\3\2\2\2\u0114\u0115\7\t\2\2\u0115")
        buf.write("\17\3\2\2\2\u0116\u0117\7\27\2\2\u0117\21\3\2\2\2\u0118")
        buf.write("\u011c\7\3\2\2\u0119\u011d\7\26\2\2\u011a\u011d\5\f\7")
        buf.write("\2\u011b\u011d\7\25\2\2\u011c\u0119\3\2\2\2\u011c\u011a")
        buf.write("\3\2\2\2\u011c\u011b\3\2\2\2\u011d\u011e\3\2\2\2\u011e")
        buf.write("\u011c\3\2\2\2\u011e\u011f\3\2\2\2\u011f\u0120\3\2\2\2")
        buf.write("\u0120\u0121\7\3\2\2\u0121\23\3\2\2\2\u0122\u0123\7\17")
        buf.write("\2\2\u0123\25\3\2\2\2\u0124\u0125\7\20\2\2\u0125\27\3")
        buf.write("\2\2\2\u0126\u0127\7\21\2\2\u0127\31\3\2\2\2\u0128\u0129")
        buf.write("\7\22\2\2\u0129\33\3\2\2\2\u012a\u012b\7\23\2\2\u012b")
        buf.write("\35\3\2\2\2\u012c\u012d\7\24\2\2\u012d\37\3\2\2\2\u012e")
        buf.write("\u0131\5\30\r\2\u012f\u0131\5\32\16\2\u0130\u012e\3\2")
        buf.write("\2\2\u0130\u012f\3\2\2\2\u0131!\3\2\2\2\u0132\u0134\7")
        buf.write("\32\2\2\u0133\u0135\5$\23\2\u0134\u0133\3\2\2\2\u0134")
        buf.write("\u0135\3\2\2\2\u0135#\3\2\2\2\u0136\u0137\5\6\4\2\u0137")
        buf.write("\u0138\7\25\2\2\u0138%\3\2\2\2\u0139\u013b\7\33\2\2\u013a")
        buf.write("\u013c\5(\25\2\u013b\u013a\3\2\2\2\u013b\u013c\3\2\2\2")
        buf.write("\u013c\'\3\2\2\2\u013d\u013e\5\n\6\2\u013e\u0140\7\25")
        buf.write("\2\2\u013f\u0141\5*\26\2\u0140\u013f\3\2\2\2\u0140\u0141")
        buf.write("\3\2\2\2\u0141\u0144\3\2\2\2\u0142\u0144\5*\26\2\u0143")
        buf.write("\u013d\3\2\2\2\u0143\u0142\3\2\2\2\u0144)\3\2\2\2\u0145")
        buf.write("\u0146\5\36\20\2\u0146\u0147\5,\27\2\u0147+\3\2\2\2\u0148")
        buf.write("\u0149\b\27\1\2\u0149\u014a\7\30\2\2\u014a\u014b\5,\27")
        buf.write("\2\u014b\u014c\7\31\2\2\u014c\u014f\3\2\2\2\u014d\u014f")
        buf.write("\5N(\2\u014e\u0148\3\2\2\2\u014e\u014d\3\2\2\2\u014f\u0158")
        buf.write("\3\2\2\2\u0150\u0151\f\5\2\2\u0151\u0152\5 \21\2\u0152")
        buf.write("\u0153\5,\27\6\u0153\u0157\3\2\2\2\u0154\u0155\f\3\2\2")
        buf.write("\u0155\u0157\7\25\2\2\u0156\u0150\3\2\2\2\u0156\u0154")
        buf.write("\3\2\2\2\u0157\u015a\3\2\2\2\u0158\u0156\3\2\2\2\u0158")
        buf.write("\u0159\3\2\2\2\u0159-\3\2\2\2\u015a\u0158\3\2\2\2\u015b")
        buf.write("\u015c\7\34\2\2\u015c\u015d\5\60\31\2\u015d/\3\2\2\2\u015e")
        buf.write("\u0163\5\26\f\2\u015f\u0160\5\6\4\2\u0160\u0161\7\25\2")
        buf.write("\2\u0161\u0164\3\2\2\2\u0162\u0164\7\35\2\2\u0163\u015f")
        buf.write("\3\2\2\2\u0163\u0162\3\2\2\2\u0164\61\3\2\2\2\u0165\u0166")
        buf.write("\7\36\2\2\u0166\u0167\5\64\33\2\u0167\63\3\2\2\2\u0168")
        buf.write("\u016d\5\26\f\2\u0169\u016a\5\6\4\2\u016a\u016b\7\25\2")
        buf.write("\2\u016b\u016e\3\2\2\2\u016c\u016e\7\37\2\2\u016d\u0169")
        buf.write("\3\2\2\2\u016d\u016c\3\2\2\2\u016e\65\3\2\2\2\u016f\u0171")
        buf.write("\7 \2\2\u0170\u0172\5:\36\2\u0171\u0170\3\2\2\2\u0171")
        buf.write("\u0172\3\2\2\2\u0172\u0174\3\2\2\2\u0173\u0175\58\35\2")
        buf.write("\u0174\u0173\3\2\2\2\u0174\u0175\3\2\2\2\u0175\67\3\2")
        buf.write("\2\2\u0176\u0177\5\26\f\2\u0177\u0178\5~@\2\u01789\3\2")
        buf.write("\2\2\u0179\u017a\5\36\20\2\u017a\u017b\5<\37\2\u017b;")
        buf.write("\3\2\2\2\u017c\u017d\b\37\1\2\u017d\u017e\7\30\2\2\u017e")
        buf.write("\u017f\5<\37\2\u017f\u0180\7\31\2\2\u0180\u018e\3\2\2")
        buf.write("\2\u0181\u018c\5&\24\2\u0182\u018c\5X-\2\u0183\u018c\5")
        buf.write("\\/\2\u0184\u018c\5T+\2\u0185\u018c\5\"\22\2\u0186\u018c")
        buf.write("\5N(\2\u0187\u018c\5`\61\2\u0188\u018c\5d\63\2\u0189\u018c")
        buf.write("\5l\67\2\u018a\u018c\5\22\n\2\u018b\u0181\3\2\2\2\u018b")
        buf.write("\u0182\3\2\2\2\u018b\u0183\3\2\2\2\u018b\u0184\3\2\2\2")
        buf.write("\u018b\u0185\3\2\2\2\u018b\u0186\3\2\2\2\u018b\u0187\3")
        buf.write("\2\2\2\u018b\u0188\3\2\2\2\u018b\u0189\3\2\2\2\u018b\u018a")
        buf.write("\3\2\2\2\u018c\u018e\3\2\2\2\u018d\u017c\3\2\2\2\u018d")
        buf.write("\u018b\3\2\2\2\u018e\u0197\3\2\2\2\u018f\u0190\f\5\2\2")
        buf.write("\u0190\u0191\5 \21\2\u0191\u0192\5<\37\6\u0192\u0196\3")
        buf.write("\2\2\2\u0193\u0194\f\3\2\2\u0194\u0196\7\25\2\2\u0195")
        buf.write("\u018f\3\2\2\2\u0195\u0193\3\2\2\2\u0196\u0199\3\2\2\2")
        buf.write("\u0197\u0195\3\2\2\2\u0197\u0198\3\2\2\2\u0198=\3\2\2")
        buf.write("\2\u0199\u0197\3\2\2\2\u019a\u019c\7!\2\2\u019b\u019d")
        buf.write("\5B\"\2\u019c\u019b\3\2\2\2\u019c\u019d\3\2\2\2\u019d")
        buf.write("\u019f\3\2\2\2\u019e\u01a0\5@!\2\u019f\u019e\3\2\2\2\u019f")
        buf.write("\u01a0\3\2\2\2\u01a0?\3\2\2\2\u01a1\u01a2\5\26\f\2\u01a2")
        buf.write("\u01a3\5~@\2\u01a3A\3\2\2\2\u01a4\u01a5\5\36\20\2\u01a5")
        buf.write("\u01a6\5D#\2\u01a6C\3\2\2\2\u01a7\u01a8\b#\1\2\u01a8\u01a9")
        buf.write("\7\30\2\2\u01a9\u01aa\5D#\2\u01aa\u01ab\7\31\2\2\u01ab")
        buf.write("\u01b5\3\2\2\2\u01ac\u01b3\5&\24\2\u01ad\u01b3\5X-\2\u01ae")
        buf.write("\u01b3\5\\/\2\u01af\u01b3\5T+\2\u01b0\u01b3\5\"\22\2\u01b1")
        buf.write("\u01b3\5N(\2\u01b2\u01ac\3\2\2\2\u01b2\u01ad\3\2\2\2\u01b2")
        buf.write("\u01ae\3\2\2\2\u01b2\u01af\3\2\2\2\u01b2\u01b0\3\2\2\2")
        buf.write("\u01b2\u01b1\3\2\2\2\u01b3\u01b5\3\2\2\2\u01b4\u01a7\3")
        buf.write("\2\2\2\u01b4\u01b2\3\2\2\2\u01b5\u01be\3\2\2\2\u01b6\u01b7")
        buf.write("\f\5\2\2\u01b7\u01b8\5 \21\2\u01b8\u01b9\5D#\6\u01b9\u01bd")
        buf.write("\3\2\2\2\u01ba\u01bb\f\3\2\2\u01bb\u01bd\7\25\2\2\u01bc")
        buf.write("\u01b6\3\2\2\2\u01bc\u01ba\3\2\2\2\u01bd\u01c0\3\2\2\2")
        buf.write("\u01be\u01bc\3\2\2\2\u01be\u01bf\3\2\2\2\u01bfE\3\2\2")
        buf.write("\2\u01c0\u01be\3\2\2\2\u01c1\u01c3\7\"\2\2\u01c2\u01c4")
        buf.write("\5J&\2\u01c3\u01c2\3\2\2\2\u01c3\u01c4\3\2\2\2\u01c4\u01c6")
        buf.write("\3\2\2\2\u01c5\u01c7\5H%\2\u01c6\u01c5\3\2\2\2\u01c6\u01c7")
        buf.write("\3\2\2\2\u01c7G\3\2\2\2\u01c8\u01c9\5\26\f\2\u01c9\u01ca")
        buf.write("\5~@\2\u01caI\3\2\2\2\u01cb\u01cc\5\36\20\2\u01cc\u01cd")
        buf.write("\5L\'\2\u01cdK\3\2\2\2\u01ce\u01cf\b\'\1\2\u01cf\u01d0")
        buf.write("\7\30\2\2\u01d0\u01d1\5L\'\2\u01d1\u01d2\7\31\2\2\u01d2")
        buf.write("\u01de\3\2\2\2\u01d3\u01dc\5&\24\2\u01d4\u01dc\5X-\2\u01d5")
        buf.write("\u01dc\5\\/\2\u01d6\u01dc\5N(\2\u01d7\u01dc\5`\61\2\u01d8")
        buf.write("\u01dc\5d\63\2\u01d9\u01dc\5l\67\2\u01da\u01dc\5\22\n")
        buf.write("\2\u01db\u01d3\3\2\2\2\u01db\u01d4\3\2\2\2\u01db\u01d5")
        buf.write("\3\2\2\2\u01db\u01d6\3\2\2\2\u01db\u01d7\3\2\2\2\u01db")
        buf.write("\u01d8\3\2\2\2\u01db\u01d9\3\2\2\2\u01db\u01da\3\2\2\2")
        buf.write("\u01dc\u01de\3\2\2\2\u01dd\u01ce\3\2\2\2\u01dd\u01db\3")
        buf.write("\2\2\2\u01de\u01e7\3\2\2\2\u01df\u01e0\f\5\2\2\u01e0\u01e1")
        buf.write("\5 \21\2\u01e1\u01e2\5L\'\6\u01e2\u01e6\3\2\2\2\u01e3")
        buf.write("\u01e4\f\3\2\2\u01e4\u01e6\7\25\2\2\u01e5\u01df\3\2\2")
        buf.write("\2\u01e5\u01e3\3\2\2\2\u01e6\u01e9\3\2\2\2\u01e7\u01e5")
        buf.write("\3\2\2\2\u01e7\u01e8\3\2\2\2\u01e8M\3\2\2\2\u01e9\u01e7")
        buf.write("\3\2\2\2\u01ea\u01ec\7#\2\2\u01eb\u01ed\5P)\2\u01ec\u01eb")
        buf.write("\3\2\2\2\u01ec\u01ed\3\2\2\2\u01edO\3\2\2\2\u01ee\u01ef")
        buf.write("\5\36\20\2\u01ef\u01f0\5R*\2\u01f0Q\3\2\2\2\u01f1\u01f2")
        buf.write("\b*\1\2\u01f2\u01f3\7\30\2\2\u01f3\u01f4\5R*\2\u01f4\u01f5")
        buf.write("\7\31\2\2\u01f5\u01fb\3\2\2\2\u01f6\u01f9\5T+\2\u01f7")
        buf.write("\u01f9\5\"\22\2\u01f8\u01f6\3\2\2\2\u01f8\u01f7\3\2\2")
        buf.write("\2\u01f9\u01fb\3\2\2\2\u01fa\u01f1\3\2\2\2\u01fa\u01f8")
        buf.write("\3\2\2\2\u01fb\u0204\3\2\2\2\u01fc\u01fd\f\5\2\2\u01fd")
        buf.write("\u01fe\5 \21\2\u01fe\u01ff\5R*\6\u01ff\u0203\3\2\2\2\u0200")
        buf.write("\u0201\f\3\2\2\u0201\u0203\7\25\2\2\u0202\u01fc\3\2\2")
        buf.write("\2\u0202\u0200\3\2\2\2\u0203\u0206\3\2\2\2\u0204\u0202")
        buf.write("\3\2\2\2\u0204\u0205\3\2\2\2\u0205S\3\2\2\2\u0206\u0204")
        buf.write("\3\2\2\2\u0207\u0209\7$\2\2\u0208\u020a\5V,\2\u0209\u0208")
        buf.write("\3\2\2\2\u0209\u020a\3\2\2\2\u020aU\3\2\2\2\u020b\u020c")
        buf.write("\5\n\6\2\u020c\u020d\7\25\2\2\u020d\u0212\3\2\2\2\u020e")
        buf.write("\u020f\5\6\4\2\u020f\u0210\7\25\2\2\u0210\u0212\3\2\2")
        buf.write("\2\u0211\u020b\3\2\2\2\u0211\u020e\3\2\2\2\u0212W\3\2")
        buf.write("\2\2\u0213\u0215\7%\2\2\u0214\u0216\5Z.\2\u0215\u0214")
        buf.write("\3\2\2\2\u0215\u0216\3\2\2\2\u0216Y\3\2\2\2\u0217\u0218")
        buf.write("\5\6\4\2\u0218\u0219\7\25\2\2\u0219[\3\2\2\2\u021a\u021c")
        buf.write("\7&\2\2\u021b\u021d\5^\60\2\u021c\u021b\3\2\2\2\u021c")
        buf.write("\u021d\3\2\2\2\u021d]\3\2\2\2\u021e\u021f\5\6\4\2\u021f")
        buf.write("\u0220\7\25\2\2\u0220_\3\2\2\2\u0221\u0223\7\'\2\2\u0222")
        buf.write("\u0224\5b\62\2\u0223\u0222\3\2\2\2\u0223\u0224\3\2\2\2")
        buf.write("\u0224a\3\2\2\2\u0225\u0226\5\n\6\2\u0226\u0227\7\25\2")
        buf.write("\2\u0227c\3\2\2\2\u0228\u022a\7(\2\2\u0229\u022b\5h\65")
        buf.write("\2\u022a\u0229\3\2\2\2\u022a\u022b\3\2\2\2\u022b\u022d")
        buf.write("\3\2\2\2\u022c\u022e\5f\64\2\u022d\u022c\3\2\2\2\u022d")
        buf.write("\u022e\3\2\2\2\u022ee\3\2\2\2\u022f\u0233\5\26\f\2\u0230")
        buf.write("\u0234\5~@\2\u0231\u0234\5\66\34\2\u0232\u0234\5F$\2\u0233")
        buf.write("\u0230\3\2\2\2\u0233\u0231\3\2\2\2\u0233\u0232\3\2\2\2")
        buf.write("\u0234g\3\2\2\2\u0235\u0236\5\36\20\2\u0236\u0237\5j\66")
        buf.write("\2\u0237i\3\2\2\2\u0238\u0239\b\66\1\2\u0239\u023a\7\30")
        buf.write("\2\2\u023a\u023b\5j\66\2\u023b\u023c\7\31\2\2\u023c\u0247")
        buf.write("\3\2\2\2\u023d\u0245\5&\24\2\u023e\u0245\5X-\2\u023f\u0245")
        buf.write("\5\\/\2\u0240\u0245\5T+\2\u0241\u0245\5\"\22\2\u0242\u0245")
        buf.write("\5x=\2\u0243\u0245\5\22\n\2\u0244\u023d\3\2\2\2\u0244")
        buf.write("\u023e\3\2\2\2\u0244\u023f\3\2\2\2\u0244\u0240\3\2\2\2")
        buf.write("\u0244\u0241\3\2\2\2\u0244\u0242\3\2\2\2\u0244\u0243\3")
        buf.write("\2\2\2\u0245\u0247\3\2\2\2\u0246\u0238\3\2\2\2\u0246\u0244")
        buf.write("\3\2\2\2\u0247\u0250\3\2\2\2\u0248\u0249\f\5\2\2\u0249")
        buf.write("\u024a\5 \21\2\u024a\u024b\5j\66\6\u024b\u024f\3\2\2\2")
        buf.write("\u024c\u024d\f\3\2\2\u024d\u024f\7\25\2\2\u024e\u0248")
        buf.write("\3\2\2\2\u024e\u024c\3\2\2\2\u024f\u0252\3\2\2\2\u0250")
        buf.write("\u024e\3\2\2\2\u0250\u0251\3\2\2\2\u0251k\3\2\2\2\u0252")
        buf.write("\u0250\3\2\2\2\u0253\u0255\7)\2\2\u0254\u0256\5p9\2\u0255")
        buf.write("\u0254\3\2\2\2\u0255\u0256\3\2\2\2\u0256\u0258\3\2\2\2")
        buf.write("\u0257\u0259\5n8\2\u0258\u0257\3\2\2\2\u0258\u0259\3\2")
        buf.write("\2\2\u0259m\3\2\2\2\u025a\u025e\5\26\f\2\u025b\u025f\5")
        buf.write("\66\34\2\u025c\u025f\5F$\2\u025d\u025f\5F$\2\u025e\u025b")
        buf.write("\3\2\2\2\u025e\u025c\3\2\2\2\u025e\u025d\3\2\2\2\u025f")
        buf.write("o\3\2\2\2\u0260\u0261\5\36\20\2\u0261\u0262\5r:\2\u0262")
        buf.write("q\3\2\2\2\u0263\u0264\b:\1\2\u0264\u0265\7\30\2\2\u0265")
        buf.write("\u0266\5r:\2\u0266\u0267\7\31\2\2\u0267\u026d\3\2\2\2")
        buf.write("\u0268\u026b\5\22\n\2\u0269\u026b\5t;\2\u026a\u0268\3")
        buf.write("\2\2\2\u026a\u0269\3\2\2\2\u026b\u026d\3\2\2\2\u026c\u0263")
        buf.write("\3\2\2\2\u026c\u026a\3\2\2\2\u026d\u0276\3\2\2\2\u026e")
        buf.write("\u026f\f\5\2\2\u026f\u0270\5 \21\2\u0270\u0271\5r:\6\u0271")
        buf.write("\u0275\3\2\2\2\u0272\u0273\f\3\2\2\u0273\u0275\7\25\2")
        buf.write("\2\u0274\u026e\3\2\2\2\u0274\u0272\3\2\2\2\u0275\u0278")
        buf.write("\3\2\2\2\u0276\u0274\3\2\2\2\u0276\u0277\3\2\2\2\u0277")
        buf.write("s\3\2\2\2\u0278\u0276\3\2\2\2\u0279\u027b\7*\2\2\u027a")
        buf.write("\u027c\5v<\2\u027b\u027a\3\2\2\2\u027b\u027c\3\2\2\2\u027c")
        buf.write("u\3\2\2\2\u027d\u027e\5\n\6\2\u027e\u027f\7\25\2\2\u027f")
        buf.write("w\3\2\2\2\u0280\u0282\7+\2\2\u0281\u0283\5|?\2\u0282\u0281")
        buf.write("\3\2\2\2\u0282\u0283\3\2\2\2\u0283\u0285\3\2\2\2\u0284")
        buf.write("\u0286\5z>\2\u0285\u0284\3\2\2\2\u0285\u0286\3\2\2\2\u0286")
        buf.write("y\3\2\2\2\u0287\u0288\5\26\f\2\u0288\u0289\5d\63\2\u0289")
        buf.write("{\3\2\2\2\u028a\u028b\5\n\6\2\u028b\u028c\7\25\2\2\u028c")
        buf.write("}\3\2\2\2\u028d\u028f\7,\2\2\u028e\u0290\5\u0080A\2\u028f")
        buf.write("\u028e\3\2\2\2\u028f\u0290\3\2\2\2\u0290\177\3\2\2\2\u0291")
        buf.write("\u0292\5\36\20\2\u0292\u0293\5\u0082B\2\u0293\u0081\3")
        buf.write("\2\2\2\u0294\u0295\bB\1\2\u0295\u0296\7\30\2\2\u0296\u0297")
        buf.write("\5\u0082B\2\u0297\u0298\7\31\2\2\u0298\u02a9\3\2\2\2\u0299")
        buf.write("\u02a7\5&\24\2\u029a\u02a7\5X-\2\u029b\u02a7\5\\/\2\u029c")
        buf.write("\u02a7\5\"\22\2\u029d\u02a7\5.\30\2\u029e\u02a7\5\62\32")
        buf.write("\2\u029f\u02a7\5\66\34\2\u02a0\u02a7\5> \2\u02a1\u02a7")
        buf.write("\5F$\2\u02a2\u02a7\5d\63\2\u02a3\u02a7\5`\61\2\u02a4\u02a7")
        buf.write("\5\22\n\2\u02a5\u02a7\5\u0084C\2\u02a6\u0299\3\2\2\2\u02a6")
        buf.write("\u029a\3\2\2\2\u02a6\u029b\3\2\2\2\u02a6\u029c\3\2\2\2")
        buf.write("\u02a6\u029d\3\2\2\2\u02a6\u029e\3\2\2\2\u02a6\u029f\3")
        buf.write("\2\2\2\u02a6\u02a0\3\2\2\2\u02a6\u02a1\3\2\2\2\u02a6\u02a2")
        buf.write("\3\2\2\2\u02a6\u02a3\3\2\2\2\u02a6\u02a4\3\2\2\2\u02a6")
        buf.write("\u02a5\3\2\2\2\u02a7\u02a9\3\2\2\2\u02a8\u0294\3\2\2\2")
        buf.write("\u02a8\u02a6\3\2\2\2\u02a9\u02b2\3\2\2\2\u02aa\u02ab\f")
        buf.write("\5\2\2\u02ab\u02ac\5 \21\2\u02ac\u02ad\5\u0082B\6\u02ad")
        buf.write("\u02b1\3\2\2\2\u02ae\u02af\f\3\2\2\u02af\u02b1\7\25\2")
        buf.write("\2\u02b0\u02aa\3\2\2\2\u02b0\u02ae\3\2\2\2\u02b1\u02b4")
        buf.write("\3\2\2\2\u02b2\u02b0\3\2\2\2\u02b2\u02b3\3\2\2\2\u02b3")
        buf.write("\u0083\3\2\2\2\u02b4\u02b2\3\2\2\2\u02b5\u02b7\7-\2\2")
        buf.write("\u02b6\u02b8\5\u0088E\2\u02b7\u02b6\3\2\2\2\u02b7\u02b8")
        buf.write("\3\2\2\2\u02b8\u02ba\3\2\2\2\u02b9\u02bb\5\u0086D\2\u02ba")
        buf.write("\u02b9\3\2\2\2\u02ba\u02bb\3\2\2\2\u02bb\u0085\3\2\2\2")
        buf.write("\u02bc\u02bd\5\26\f\2\u02bd\u02be\5~@\2\u02be\u0087\3")
        buf.write("\2\2\2\u02bf\u02c0\5\36\20\2\u02c0\u02c1\5\u008aF\2\u02c1")
        buf.write("\u0089\3\2\2\2\u02c2\u02c3\bF\1\2\u02c3\u02c4\7\30\2\2")
        buf.write("\u02c4\u02c5\5\u008aF\2\u02c5\u02c6\7\31\2\2\u02c6\u02d8")
        buf.write("\3\2\2\2\u02c7\u02d6\5&\24\2\u02c8\u02d6\5X-\2\u02c9\u02d6")
        buf.write("\5\\/\2\u02ca\u02d6\5\"\22\2\u02cb\u02d6\5.\30\2\u02cc")
        buf.write("\u02d6\5\62\32\2\u02cd\u02d6\5\66\34\2\u02ce\u02d6\5\u0084")
        buf.write("C\2\u02cf\u02d6\3\2\2\2\u02d0\u02d6\5> \2\u02d1\u02d6")
        buf.write("\5F$\2\u02d2\u02d6\5d\63\2\u02d3\u02d6\5`\61\2\u02d4\u02d6")
        buf.write("\5\22\n\2\u02d5\u02c7\3\2\2\2\u02d5\u02c8\3\2\2\2\u02d5")
        buf.write("\u02c9\3\2\2\2\u02d5\u02ca\3\2\2\2\u02d5\u02cb\3\2\2\2")
        buf.write("\u02d5\u02cc\3\2\2\2\u02d5\u02cd\3\2\2\2\u02d5\u02ce\3")
        buf.write("\2\2\2\u02d5\u02cf\3\2\2\2\u02d5\u02d0\3\2\2\2\u02d5\u02d1")
        buf.write("\3\2\2\2\u02d5\u02d2\3\2\2\2\u02d5\u02d3\3\2\2\2\u02d5")
        buf.write("\u02d4\3\2\2\2\u02d6\u02d8\3\2\2\2\u02d7\u02c2\3\2\2\2")
        buf.write("\u02d7\u02d5\3\2\2\2\u02d8\u02e1\3\2\2\2\u02d9\u02da\f")
        buf.write("\5\2\2\u02da\u02db\5 \21\2\u02db\u02dc\5\u008aF\6\u02dc")
        buf.write("\u02e0\3\2\2\2\u02dd\u02de\f\3\2\2\u02de\u02e0\7\25\2")
        buf.write("\2\u02df\u02d9\3\2\2\2\u02df\u02dd\3\2\2\2\u02e0\u02e3")
        buf.write("\3\2\2\2\u02e1\u02df\3\2\2\2\u02e1\u02e2\3\2\2\2\u02e2")
        buf.write("\u008b\3\2\2\2\u02e3\u02e1\3\2\2\2X\u008f\u0093\u0096")
        buf.write("\u009b\u00c3\u00cc\u00ce\u00d7\u00dd\u00e3\u00e9\u00ee")
        buf.write("\u00f5\u00fc\u0103\u0106\u010c\u010e\u011c\u011e\u0130")
        buf.write("\u0134\u013b\u0140\u0143\u014e\u0156\u0158\u0163\u016d")
        buf.write("\u0171\u0174\u018b\u018d\u0195\u0197\u019c\u019f\u01b2")
        buf.write("\u01b4\u01bc\u01be\u01c3\u01c6\u01db\u01dd\u01e5\u01e7")
        buf.write("\u01ec\u01f8\u01fa\u0202\u0204\u0209\u0211\u0215\u021c")
        buf.write("\u0223\u022a\u022d\u0233\u0244\u0246\u024e\u0250\u0255")
        buf.write("\u0258\u025e\u026a\u026c\u0274\u0276\u027b\u0282\u0285")
        buf.write("\u028f\u02a6\u02a8\u02b0\u02b2\u02b7\u02ba\u02d5\u02d7")
        buf.write("\u02df\u02e1")
        return buf.getvalue()


class RulepadGrammarParser ( Parser ):

    grammarFileName = "RulepadGrammar.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'\"'", "'||'", "'&&'", "'!'", "'...'", 
                     "'!...'", "'.'", "'='", "'>'", "'<'", "'''", "'&'", 
                     "'must '", "'of '", "'and '", "'or '", "'have '", "'with '", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'('", "')'", 
                     "'name '", "'annotation '", "'extension '", "'Superclass'", 
                     "'implementation '", "'Interface '", "'function '", 
                     "'abstract function '", "'constructor '", "'parameter '", 
                     "'type '", "'specifier '", "'visibility '", "'return value '", 
                     "'declaration statement '", "'expression statement '", 
                     "'value '", "'initial value '", "'class '", "'subclass '" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "SPACE", "Alphabet", 
                      "NL", "LPAREN", "RPAREN", "NAME", "ANNOTATION", "EXTENSION", 
                      "SUPERCLASS", "IMPLEMENTATION", "INTERFACE", "FUNCTION", 
                      "AbstractFunctions", "CONSTRUCTOR", "PARAMETER", "TYPES", 
                      "SPECIFIER", "VISIBILITY", "ReturnValue", "DeclarationStatement", 
                      "ExpressionStatement", "VALUE", "InitialValue", "CLASSES", 
                      "SUBCLASSES" ]

    RULE_inputSentence = 0
    RULE_mustClause = 1
    RULE_words = 2
    RULE_word = 3
    RULE_combinatorialWords = 4
    RULE_symbols = 5
    RULE_end = 6
    RULE_emptyLine = 7
    RULE_comments = 8
    RULE_must = 9
    RULE_of = 10
    RULE_and_ = 11
    RULE_or_ = 12
    RULE_have = 13
    RULE_withWord = 14
    RULE_binary = 15
    RULE_names = 16
    RULE_nameCondition = 17
    RULE_annotations = 18
    RULE_annotationCondition = 19
    RULE_annotationConditionTransition = 20
    RULE_annotationExpression = 21
    RULE_extensions = 22
    RULE_extensionCondition = 23
    RULE_implementations = 24
    RULE_implementationCondition = 25
    RULE_functions = 26
    RULE_functionOf = 27
    RULE_functionCondition = 28
    RULE_functionExpression = 29
    RULE_abstractFunctions = 30
    RULE_abstractFunctionOf = 31
    RULE_abstractFunctionCondition = 32
    RULE_abstractFunctionExpression = 33
    RULE_constructors = 34
    RULE_constructorOf = 35
    RULE_constructorCondition = 36
    RULE_constructorExpression = 37
    RULE_parameters = 38
    RULE_parameterCondition = 39
    RULE_parameterExpression = 40
    RULE_types = 41
    RULE_typeCondition = 42
    RULE_specifiers = 43
    RULE_specifierCondition = 44
    RULE_visibilities = 45
    RULE_visibilityCondition = 46
    RULE_returnValues = 47
    RULE_returnValueCondition = 48
    RULE_declarationStatements = 49
    RULE_declarationStatementOf = 50
    RULE_declarationStatementCondition = 51
    RULE_declarationStatementExpression = 52
    RULE_expressionStatements = 53
    RULE_expressionStatementOf = 54
    RULE_expressionStatementCondition = 55
    RULE_expressionStatementExpression = 56
    RULE_value = 57
    RULE_valueCondition = 58
    RULE_initialValues = 59
    RULE_initialValueOf = 60
    RULE_initialValueCondition = 61
    RULE_classes = 62
    RULE_classCondition = 63
    RULE_classExpression = 64
    RULE_subclasses = 65
    RULE_subclassOf = 66
    RULE_subclassCondition = 67
    RULE_subclassExpression = 68

    ruleNames =  [ "inputSentence", "mustClause", "words", "word", "combinatorialWords", 
                   "symbols", "end", "emptyLine", "comments", "must", "of", 
                   "and_", "or_", "have", "withWord", "binary", "names", 
                   "nameCondition", "annotations", "annotationCondition", 
                   "annotationConditionTransition", "annotationExpression", 
                   "extensions", "extensionCondition", "implementations", 
                   "implementationCondition", "functions", "functionOf", 
                   "functionCondition", "functionExpression", "abstractFunctions", 
                   "abstractFunctionOf", "abstractFunctionCondition", "abstractFunctionExpression", 
                   "constructors", "constructorOf", "constructorCondition", 
                   "constructorExpression", "parameters", "parameterCondition", 
                   "parameterExpression", "types", "typeCondition", "specifiers", 
                   "specifierCondition", "visibilities", "visibilityCondition", 
                   "returnValues", "returnValueCondition", "declarationStatements", 
                   "declarationStatementOf", "declarationStatementCondition", 
                   "declarationStatementExpression", "expressionStatements", 
                   "expressionStatementOf", "expressionStatementCondition", 
                   "expressionStatementExpression", "value", "valueCondition", 
                   "initialValues", "initialValueOf", "initialValueCondition", 
                   "classes", "classCondition", "classExpression", "subclasses", 
                   "subclassOf", "subclassCondition", "subclassExpression" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    SPACE=19
    Alphabet=20
    NL=21
    LPAREN=22
    RPAREN=23
    NAME=24
    ANNOTATION=25
    EXTENSION=26
    SUPERCLASS=27
    IMPLEMENTATION=28
    INTERFACE=29
    FUNCTION=30
    AbstractFunctions=31
    CONSTRUCTOR=32
    PARAMETER=33
    TYPES=34
    SPECIFIER=35
    VISIBILITY=36
    ReturnValue=37
    DeclarationStatement=38
    ExpressionStatement=39
    VALUE=40
    InitialValue=41
    CLASSES=42
    SUBCLASSES=43

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class InputSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(RulepadGrammarParser.EOF, 0)

        def mustClause(self):
            return self.getTypedRuleContext(RulepadGrammarParser.MustClauseContext,0)


        def end(self):
            return self.getTypedRuleContext(RulepadGrammarParser.EndContext,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(RulepadGrammarParser.NL)
            else:
                return self.getToken(RulepadGrammarParser.NL, i)

        def emptyLine(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulepadGrammarParser.EmptyLineContext)
            else:
                return self.getTypedRuleContext(RulepadGrammarParser.EmptyLineContext,i)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_inputSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInputSentence" ):
                listener.enterInputSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInputSentence" ):
                listener.exitInputSentence(self)




    def inputSentence(self):

        localctx = RulepadGrammarParser.InputSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_inputSentence)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 145
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.EOF, RulepadGrammarParser.T__6, RulepadGrammarParser.NL]:
                self.state = 141
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 138
                        self.emptyLine() 
                    self.state = 143
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

                pass
            elif token in [RulepadGrammarParser.FUNCTION, RulepadGrammarParser.AbstractFunctions, RulepadGrammarParser.CONSTRUCTOR, RulepadGrammarParser.PARAMETER, RulepadGrammarParser.DeclarationStatement, RulepadGrammarParser.CLASSES, RulepadGrammarParser.SUBCLASSES]:
                self.state = 144
                self.mustClause()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 148
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==RulepadGrammarParser.T__6:
                self.state = 147
                self.end()


            self.state = 153
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RulepadGrammarParser.NL:
                self.state = 150
                self.match(RulepadGrammarParser.NL)
                self.state = 155
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 156
            self.match(RulepadGrammarParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MustClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functions(self):
            return self.getTypedRuleContext(RulepadGrammarParser.FunctionsContext,0)


        def must(self):
            return self.getTypedRuleContext(RulepadGrammarParser.MustContext,0)


        def have(self):
            return self.getTypedRuleContext(RulepadGrammarParser.HaveContext,0)


        def functionExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.FunctionExpressionContext,0)


        def abstractFunctions(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AbstractFunctionsContext,0)


        def abstractFunctionExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AbstractFunctionExpressionContext,0)


        def constructors(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ConstructorsContext,0)


        def constructorExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ConstructorExpressionContext,0)


        def classes(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ClassesContext,0)


        def classExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ClassExpressionContext,0)


        def parameters(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ParametersContext,0)


        def parameterExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ParameterExpressionContext,0)


        def declarationStatements(self):
            return self.getTypedRuleContext(RulepadGrammarParser.DeclarationStatementsContext,0)


        def declarationStatementExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.DeclarationStatementExpressionContext,0)


        def subclasses(self):
            return self.getTypedRuleContext(RulepadGrammarParser.SubclassesContext,0)


        def subclassExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.SubclassExpressionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_mustClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMustClause" ):
                listener.enterMustClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMustClause" ):
                listener.exitMustClause(self)




    def mustClause(self):

        localctx = RulepadGrammarParser.MustClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_mustClause)
        try:
            self.state = 193
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.FUNCTION]:
                self.enterOuterAlt(localctx, 1)
                self.state = 158
                self.functions()
                self.state = 159
                self.must()
                self.state = 160
                self.have()
                self.state = 161
                self.functionExpression(0)
                pass
            elif token in [RulepadGrammarParser.AbstractFunctions]:
                self.enterOuterAlt(localctx, 2)
                self.state = 163
                self.abstractFunctions()
                self.state = 164
                self.must()
                self.state = 165
                self.have()
                self.state = 166
                self.abstractFunctionExpression(0)
                pass
            elif token in [RulepadGrammarParser.CONSTRUCTOR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 168
                self.constructors()
                self.state = 169
                self.must()
                self.state = 170
                self.have()
                self.state = 171
                self.constructorExpression(0)
                pass
            elif token in [RulepadGrammarParser.CLASSES]:
                self.enterOuterAlt(localctx, 4)
                self.state = 173
                self.classes()
                self.state = 174
                self.must()
                self.state = 175
                self.have()
                self.state = 176
                self.classExpression(0)
                pass
            elif token in [RulepadGrammarParser.PARAMETER]:
                self.enterOuterAlt(localctx, 5)
                self.state = 178
                self.parameters()
                self.state = 179
                self.must()
                self.state = 180
                self.have()
                self.state = 181
                self.parameterExpression(0)
                pass
            elif token in [RulepadGrammarParser.DeclarationStatement]:
                self.enterOuterAlt(localctx, 6)
                self.state = 183
                self.declarationStatements()
                self.state = 184
                self.must()
                self.state = 185
                self.have()
                self.state = 186
                self.declarationStatementExpression(0)
                pass
            elif token in [RulepadGrammarParser.SUBCLASSES]:
                self.enterOuterAlt(localctx, 7)
                self.state = 188
                self.subclasses()
                self.state = 189
                self.must()
                self.state = 190
                self.have()
                self.state = 191
                self.subclassExpression(0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WordsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def word(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulepadGrammarParser.WordContext)
            else:
                return self.getTypedRuleContext(RulepadGrammarParser.WordContext,i)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_words

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWords" ):
                listener.enterWords(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWords" ):
                listener.exitWords(self)




    def words(self):

        localctx = RulepadGrammarParser.WordsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_words)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            self.match(RulepadGrammarParser.T__0)
            self.state = 204
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 202
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
                    if la_ == 1:
                        self.state = 196
                        self.word()
                        self.state = 197
                        self.match(RulepadGrammarParser.T__1)
                        pass

                    elif la_ == 2:
                        self.state = 199
                        self.word()
                        self.state = 200
                        self.match(RulepadGrammarParser.T__2)
                        pass

             
                self.state = 206
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

            self.state = 207
            self.word()
            self.state = 208
            self.match(RulepadGrammarParser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Alphabet(self, i:int=None):
            if i is None:
                return self.getTokens(RulepadGrammarParser.Alphabet)
            else:
                return self.getToken(RulepadGrammarParser.Alphabet, i)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_word

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWord" ):
                listener.enterWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWord" ):
                listener.exitWord(self)




    def word(self):

        localctx = RulepadGrammarParser.WordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_word)
        self._la = 0 # Token type
        try:
            self.state = 260
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 211 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 210
                    self.match(RulepadGrammarParser.Alphabet)
                    self.state = 213 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==RulepadGrammarParser.Alphabet):
                        break

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 215
                self.match(RulepadGrammarParser.T__3)
                self.state = 217 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 216
                    self.match(RulepadGrammarParser.Alphabet)
                    self.state = 219 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==RulepadGrammarParser.Alphabet):
                        break

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 221
                self.match(RulepadGrammarParser.T__4)
                self.state = 223 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 222
                    self.match(RulepadGrammarParser.Alphabet)
                    self.state = 225 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==RulepadGrammarParser.Alphabet):
                        break

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 227
                self.match(RulepadGrammarParser.T__5)
                self.state = 229 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 228
                    self.match(RulepadGrammarParser.Alphabet)
                    self.state = 231 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==RulepadGrammarParser.Alphabet):
                        break

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 234 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 233
                    self.match(RulepadGrammarParser.Alphabet)
                    self.state = 236 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==RulepadGrammarParser.Alphabet):
                        break

                self.state = 238
                self.match(RulepadGrammarParser.T__4)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 239
                self.match(RulepadGrammarParser.T__3)
                self.state = 241 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 240
                    self.match(RulepadGrammarParser.Alphabet)
                    self.state = 243 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==RulepadGrammarParser.Alphabet):
                        break

                self.state = 245
                self.match(RulepadGrammarParser.T__4)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 246
                self.match(RulepadGrammarParser.T__4)
                self.state = 248 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 247
                    self.match(RulepadGrammarParser.Alphabet)
                    self.state = 250 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==RulepadGrammarParser.Alphabet):
                        break

                self.state = 252
                self.match(RulepadGrammarParser.T__4)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 253
                self.match(RulepadGrammarParser.T__5)
                self.state = 255 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 254
                    self.match(RulepadGrammarParser.Alphabet)
                    self.state = 257 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==RulepadGrammarParser.Alphabet):
                        break

                self.state = 259
                self.match(RulepadGrammarParser.T__4)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CombinatorialWordsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Alphabet(self, i:int=None):
            if i is None:
                return self.getTokens(RulepadGrammarParser.Alphabet)
            else:
                return self.getToken(RulepadGrammarParser.Alphabet, i)

        def symbols(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulepadGrammarParser.SymbolsContext)
            else:
                return self.getTypedRuleContext(RulepadGrammarParser.SymbolsContext,i)


        def SPACE(self, i:int=None):
            if i is None:
                return self.getTokens(RulepadGrammarParser.SPACE)
            else:
                return self.getToken(RulepadGrammarParser.SPACE, i)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_combinatorialWords

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCombinatorialWords" ):
                listener.enterCombinatorialWords(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCombinatorialWords" ):
                listener.exitCombinatorialWords(self)




    def combinatorialWords(self):

        localctx = RulepadGrammarParser.CombinatorialWordsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_combinatorialWords)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            self.match(RulepadGrammarParser.T__0)
            self.state = 266 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 266
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RulepadGrammarParser.Alphabet]:
                    self.state = 263
                    self.match(RulepadGrammarParser.Alphabet)
                    pass
                elif token in [RulepadGrammarParser.T__6, RulepadGrammarParser.T__7, RulepadGrammarParser.T__8, RulepadGrammarParser.T__9, RulepadGrammarParser.T__10, RulepadGrammarParser.T__11, RulepadGrammarParser.LPAREN, RulepadGrammarParser.RPAREN]:
                    self.state = 264
                    self.symbols()
                    pass
                elif token in [RulepadGrammarParser.SPACE]:
                    self.state = 265
                    self.match(RulepadGrammarParser.SPACE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 268 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << RulepadGrammarParser.T__6) | (1 << RulepadGrammarParser.T__7) | (1 << RulepadGrammarParser.T__8) | (1 << RulepadGrammarParser.T__9) | (1 << RulepadGrammarParser.T__10) | (1 << RulepadGrammarParser.T__11) | (1 << RulepadGrammarParser.SPACE) | (1 << RulepadGrammarParser.Alphabet) | (1 << RulepadGrammarParser.LPAREN) | (1 << RulepadGrammarParser.RPAREN))) != 0)):
                    break

            self.state = 270
            self.match(RulepadGrammarParser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SymbolsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(RulepadGrammarParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(RulepadGrammarParser.RPAREN, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_symbols

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSymbols" ):
                listener.enterSymbols(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSymbols" ):
                listener.exitSymbols(self)




    def symbols(self):

        localctx = RulepadGrammarParser.SymbolsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_symbols)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 272
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << RulepadGrammarParser.T__6) | (1 << RulepadGrammarParser.T__7) | (1 << RulepadGrammarParser.T__8) | (1 << RulepadGrammarParser.T__9) | (1 << RulepadGrammarParser.T__10) | (1 << RulepadGrammarParser.T__11) | (1 << RulepadGrammarParser.LPAREN) | (1 << RulepadGrammarParser.RPAREN))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_end

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnd" ):
                listener.enterEnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnd" ):
                listener.exitEnd(self)




    def end(self):

        localctx = RulepadGrammarParser.EndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_end)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self.match(RulepadGrammarParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EmptyLineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NL(self):
            return self.getToken(RulepadGrammarParser.NL, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_emptyLine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmptyLine" ):
                listener.enterEmptyLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmptyLine" ):
                listener.exitEmptyLine(self)




    def emptyLine(self):

        localctx = RulepadGrammarParser.EmptyLineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_emptyLine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 276
            self.match(RulepadGrammarParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Alphabet(self, i:int=None):
            if i is None:
                return self.getTokens(RulepadGrammarParser.Alphabet)
            else:
                return self.getToken(RulepadGrammarParser.Alphabet, i)

        def symbols(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulepadGrammarParser.SymbolsContext)
            else:
                return self.getTypedRuleContext(RulepadGrammarParser.SymbolsContext,i)


        def SPACE(self, i:int=None):
            if i is None:
                return self.getTokens(RulepadGrammarParser.SPACE)
            else:
                return self.getToken(RulepadGrammarParser.SPACE, i)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_comments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComments" ):
                listener.enterComments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComments" ):
                listener.exitComments(self)




    def comments(self):

        localctx = RulepadGrammarParser.CommentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_comments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 278
            self.match(RulepadGrammarParser.T__0)
            self.state = 282 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 282
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RulepadGrammarParser.Alphabet]:
                    self.state = 279
                    self.match(RulepadGrammarParser.Alphabet)
                    pass
                elif token in [RulepadGrammarParser.T__6, RulepadGrammarParser.T__7, RulepadGrammarParser.T__8, RulepadGrammarParser.T__9, RulepadGrammarParser.T__10, RulepadGrammarParser.T__11, RulepadGrammarParser.LPAREN, RulepadGrammarParser.RPAREN]:
                    self.state = 280
                    self.symbols()
                    pass
                elif token in [RulepadGrammarParser.SPACE]:
                    self.state = 281
                    self.match(RulepadGrammarParser.SPACE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 284 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << RulepadGrammarParser.T__6) | (1 << RulepadGrammarParser.T__7) | (1 << RulepadGrammarParser.T__8) | (1 << RulepadGrammarParser.T__9) | (1 << RulepadGrammarParser.T__10) | (1 << RulepadGrammarParser.T__11) | (1 << RulepadGrammarParser.SPACE) | (1 << RulepadGrammarParser.Alphabet) | (1 << RulepadGrammarParser.LPAREN) | (1 << RulepadGrammarParser.RPAREN))) != 0)):
                    break

            self.state = 286
            self.match(RulepadGrammarParser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MustContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_must

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMust" ):
                listener.enterMust(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMust" ):
                listener.exitMust(self)




    def must(self):

        localctx = RulepadGrammarParser.MustContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_must)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 288
            self.match(RulepadGrammarParser.T__12)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_of

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOf" ):
                listener.enterOf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOf" ):
                listener.exitOf(self)




    def of(self):

        localctx = RulepadGrammarParser.OfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_of)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 290
            self.match(RulepadGrammarParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class And_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_and_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnd_" ):
                listener.enterAnd_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnd_" ):
                listener.exitAnd_(self)




    def and_(self):

        localctx = RulepadGrammarParser.And_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_and_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 292
            self.match(RulepadGrammarParser.T__14)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Or_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_or_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOr_" ):
                listener.enterOr_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOr_" ):
                listener.exitOr_(self)




    def or_(self):

        localctx = RulepadGrammarParser.Or_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_or_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 294
            self.match(RulepadGrammarParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HaveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_have

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHave" ):
                listener.enterHave(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHave" ):
                listener.exitHave(self)




    def have(self):

        localctx = RulepadGrammarParser.HaveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_have)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 296
            self.match(RulepadGrammarParser.T__16)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_withWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithWord" ):
                listener.enterWithWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithWord" ):
                listener.exitWithWord(self)




    def withWord(self):

        localctx = RulepadGrammarParser.WithWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_withWord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 298
            self.match(RulepadGrammarParser.T__17)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def and_(self):
            return self.getTypedRuleContext(RulepadGrammarParser.And_Context,0)


        def or_(self):
            return self.getTypedRuleContext(RulepadGrammarParser.Or_Context,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_binary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinary" ):
                listener.enterBinary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinary" ):
                listener.exitBinary(self)




    def binary(self):

        localctx = RulepadGrammarParser.BinaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_binary)
        try:
            self.state = 302
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.T__14]:
                self.enterOuterAlt(localctx, 1)
                self.state = 300
                self.and_()
                pass
            elif token in [RulepadGrammarParser.T__15]:
                self.enterOuterAlt(localctx, 2)
                self.state = 301
                self.or_()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(RulepadGrammarParser.NAME, 0)

        def nameCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.NameConditionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_names

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNames" ):
                listener.enterNames(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNames" ):
                listener.exitNames(self)




    def names(self):

        localctx = RulepadGrammarParser.NamesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_names)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            self.match(RulepadGrammarParser.NAME)
            self.state = 306
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.state = 305
                self.nameCondition()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def words(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WordsContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_nameCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNameCondition" ):
                listener.enterNameCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNameCondition" ):
                listener.exitNameCondition(self)




    def nameCondition(self):

        localctx = RulepadGrammarParser.NameConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_nameCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 308
            self.words()
            self.state = 309
            self.match(RulepadGrammarParser.SPACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANNOTATION(self):
            return self.getToken(RulepadGrammarParser.ANNOTATION, 0)

        def annotationCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AnnotationConditionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_annotations

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotations" ):
                listener.enterAnnotations(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotations" ):
                listener.exitAnnotations(self)




    def annotations(self):

        localctx = RulepadGrammarParser.AnnotationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_annotations)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 311
            self.match(RulepadGrammarParser.ANNOTATION)
            self.state = 313
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.state = 312
                self.annotationCondition()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotationConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def combinatorialWords(self):
            return self.getTypedRuleContext(RulepadGrammarParser.CombinatorialWordsContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def annotationConditionTransition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AnnotationConditionTransitionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_annotationCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotationCondition" ):
                listener.enterAnnotationCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotationCondition" ):
                listener.exitAnnotationCondition(self)




    def annotationCondition(self):

        localctx = RulepadGrammarParser.AnnotationConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_annotationCondition)
        try:
            self.state = 321
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.T__0]:
                self.enterOuterAlt(localctx, 1)
                self.state = 315
                self.combinatorialWords()
                self.state = 316
                self.match(RulepadGrammarParser.SPACE)
                self.state = 318
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
                if la_ == 1:
                    self.state = 317
                    self.annotationConditionTransition()


                pass
            elif token in [RulepadGrammarParser.T__17]:
                self.enterOuterAlt(localctx, 2)
                self.state = 320
                self.annotationConditionTransition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotationConditionTransitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withWord(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WithWordContext,0)


        def annotationExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AnnotationExpressionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_annotationConditionTransition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotationConditionTransition" ):
                listener.enterAnnotationConditionTransition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotationConditionTransition" ):
                listener.exitAnnotationConditionTransition(self)




    def annotationConditionTransition(self):

        localctx = RulepadGrammarParser.AnnotationConditionTransitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_annotationConditionTransition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 323
            self.withWord()
            self.state = 324
            self.annotationExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotationExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # AnnotationExpressionContext
            self.op = None # BinaryContext
            self.right = None # AnnotationExpressionContext

        def LPAREN(self):
            return self.getToken(RulepadGrammarParser.LPAREN, 0)

        def annotationExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulepadGrammarParser.AnnotationExpressionContext)
            else:
                return self.getTypedRuleContext(RulepadGrammarParser.AnnotationExpressionContext,i)


        def RPAREN(self):
            return self.getToken(RulepadGrammarParser.RPAREN, 0)

        def parameters(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ParametersContext,0)


        def binary(self):
            return self.getTypedRuleContext(RulepadGrammarParser.BinaryContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_annotationExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotationExpression" ):
                listener.enterAnnotationExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotationExpression" ):
                listener.exitAnnotationExpression(self)



    def annotationExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RulepadGrammarParser.AnnotationExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 42
        self.enterRecursionRule(localctx, 42, self.RULE_annotationExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 332
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.LPAREN]:
                self.state = 327
                self.match(RulepadGrammarParser.LPAREN)
                self.state = 328
                self.annotationExpression(0)
                self.state = 329
                self.match(RulepadGrammarParser.RPAREN)
                pass
            elif token in [RulepadGrammarParser.PARAMETER]:
                self.state = 331
                self.parameters()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 342
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,27,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 340
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
                    if la_ == 1:
                        localctx = RulepadGrammarParser.AnnotationExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_annotationExpression)
                        self.state = 334
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 335
                        localctx.op = self.binary()
                        self.state = 336
                        localctx.right = self.annotationExpression(4)
                        pass

                    elif la_ == 2:
                        localctx = RulepadGrammarParser.AnnotationExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_annotationExpression)
                        self.state = 338
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 339
                        self.match(RulepadGrammarParser.SPACE)
                        pass

             
                self.state = 344
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,27,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ExtensionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTENSION(self):
            return self.getToken(RulepadGrammarParser.EXTENSION, 0)

        def extensionCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ExtensionConditionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_extensions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtensions" ):
                listener.enterExtensions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtensions" ):
                listener.exitExtensions(self)




    def extensions(self):

        localctx = RulepadGrammarParser.ExtensionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_extensions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 345
            self.match(RulepadGrammarParser.EXTENSION)
            self.state = 346
            self.extensionCondition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtensionConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def of(self):
            return self.getTypedRuleContext(RulepadGrammarParser.OfContext,0)


        def words(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WordsContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def SUPERCLASS(self):
            return self.getToken(RulepadGrammarParser.SUPERCLASS, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_extensionCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtensionCondition" ):
                listener.enterExtensionCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtensionCondition" ):
                listener.exitExtensionCondition(self)




    def extensionCondition(self):

        localctx = RulepadGrammarParser.ExtensionConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_extensionCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 348
            self.of()
            self.state = 353
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.T__0]:
                self.state = 349
                self.words()
                self.state = 350
                self.match(RulepadGrammarParser.SPACE)
                pass
            elif token in [RulepadGrammarParser.SUPERCLASS]:
                self.state = 352
                self.match(RulepadGrammarParser.SUPERCLASS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImplementationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPLEMENTATION(self):
            return self.getToken(RulepadGrammarParser.IMPLEMENTATION, 0)

        def implementationCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ImplementationConditionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_implementations

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImplementations" ):
                listener.enterImplementations(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImplementations" ):
                listener.exitImplementations(self)




    def implementations(self):

        localctx = RulepadGrammarParser.ImplementationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_implementations)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 355
            self.match(RulepadGrammarParser.IMPLEMENTATION)
            self.state = 356
            self.implementationCondition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImplementationConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def of(self):
            return self.getTypedRuleContext(RulepadGrammarParser.OfContext,0)


        def words(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WordsContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def INTERFACE(self):
            return self.getToken(RulepadGrammarParser.INTERFACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_implementationCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImplementationCondition" ):
                listener.enterImplementationCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImplementationCondition" ):
                listener.exitImplementationCondition(self)




    def implementationCondition(self):

        localctx = RulepadGrammarParser.ImplementationConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_implementationCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 358
            self.of()
            self.state = 363
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.T__0]:
                self.state = 359
                self.words()
                self.state = 360
                self.match(RulepadGrammarParser.SPACE)
                pass
            elif token in [RulepadGrammarParser.INTERFACE]:
                self.state = 362
                self.match(RulepadGrammarParser.INTERFACE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNCTION(self):
            return self.getToken(RulepadGrammarParser.FUNCTION, 0)

        def functionCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.FunctionConditionContext,0)


        def functionOf(self):
            return self.getTypedRuleContext(RulepadGrammarParser.FunctionOfContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_functions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctions" ):
                listener.enterFunctions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctions" ):
                listener.exitFunctions(self)




    def functions(self):

        localctx = RulepadGrammarParser.FunctionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_functions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 365
            self.match(RulepadGrammarParser.FUNCTION)
            self.state = 367
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.state = 366
                self.functionCondition()


            self.state = 370
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.state = 369
                self.functionOf()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionOfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def of(self):
            return self.getTypedRuleContext(RulepadGrammarParser.OfContext,0)


        def classes(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ClassesContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_functionOf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionOf" ):
                listener.enterFunctionOf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionOf" ):
                listener.exitFunctionOf(self)




    def functionOf(self):

        localctx = RulepadGrammarParser.FunctionOfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_functionOf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 372
            self.of()
            self.state = 373
            self.classes()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withWord(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WithWordContext,0)


        def functionExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.FunctionExpressionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_functionCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCondition" ):
                listener.enterFunctionCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCondition" ):
                listener.exitFunctionCondition(self)




    def functionCondition(self):

        localctx = RulepadGrammarParser.FunctionConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_functionCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 375
            self.withWord()
            self.state = 376
            self.functionExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # FunctionExpressionContext
            self.op = None # BinaryContext
            self.right = None # FunctionExpressionContext

        def LPAREN(self):
            return self.getToken(RulepadGrammarParser.LPAREN, 0)

        def functionExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulepadGrammarParser.FunctionExpressionContext)
            else:
                return self.getTypedRuleContext(RulepadGrammarParser.FunctionExpressionContext,i)


        def RPAREN(self):
            return self.getToken(RulepadGrammarParser.RPAREN, 0)

        def annotations(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AnnotationsContext,0)


        def specifiers(self):
            return self.getTypedRuleContext(RulepadGrammarParser.SpecifiersContext,0)


        def visibilities(self):
            return self.getTypedRuleContext(RulepadGrammarParser.VisibilitiesContext,0)


        def types(self):
            return self.getTypedRuleContext(RulepadGrammarParser.TypesContext,0)


        def names(self):
            return self.getTypedRuleContext(RulepadGrammarParser.NamesContext,0)


        def parameters(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ParametersContext,0)


        def returnValues(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ReturnValuesContext,0)


        def declarationStatements(self):
            return self.getTypedRuleContext(RulepadGrammarParser.DeclarationStatementsContext,0)


        def expressionStatements(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ExpressionStatementsContext,0)


        def comments(self):
            return self.getTypedRuleContext(RulepadGrammarParser.CommentsContext,0)


        def binary(self):
            return self.getTypedRuleContext(RulepadGrammarParser.BinaryContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_functionExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionExpression" ):
                listener.enterFunctionExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionExpression" ):
                listener.exitFunctionExpression(self)



    def functionExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RulepadGrammarParser.FunctionExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 58
        self.enterRecursionRule(localctx, 58, self.RULE_functionExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 395
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.LPAREN]:
                self.state = 379
                self.match(RulepadGrammarParser.LPAREN)
                self.state = 380
                self.functionExpression(0)
                self.state = 381
                self.match(RulepadGrammarParser.RPAREN)
                pass
            elif token in [RulepadGrammarParser.T__0, RulepadGrammarParser.NAME, RulepadGrammarParser.ANNOTATION, RulepadGrammarParser.PARAMETER, RulepadGrammarParser.TYPES, RulepadGrammarParser.SPECIFIER, RulepadGrammarParser.VISIBILITY, RulepadGrammarParser.ReturnValue, RulepadGrammarParser.DeclarationStatement, RulepadGrammarParser.ExpressionStatement]:
                self.state = 393
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RulepadGrammarParser.ANNOTATION]:
                    self.state = 383
                    self.annotations()
                    pass
                elif token in [RulepadGrammarParser.SPECIFIER]:
                    self.state = 384
                    self.specifiers()
                    pass
                elif token in [RulepadGrammarParser.VISIBILITY]:
                    self.state = 385
                    self.visibilities()
                    pass
                elif token in [RulepadGrammarParser.TYPES]:
                    self.state = 386
                    self.types()
                    pass
                elif token in [RulepadGrammarParser.NAME]:
                    self.state = 387
                    self.names()
                    pass
                elif token in [RulepadGrammarParser.PARAMETER]:
                    self.state = 388
                    self.parameters()
                    pass
                elif token in [RulepadGrammarParser.ReturnValue]:
                    self.state = 389
                    self.returnValues()
                    pass
                elif token in [RulepadGrammarParser.DeclarationStatement]:
                    self.state = 390
                    self.declarationStatements()
                    pass
                elif token in [RulepadGrammarParser.ExpressionStatement]:
                    self.state = 391
                    self.expressionStatements()
                    pass
                elif token in [RulepadGrammarParser.T__0]:
                    self.state = 392
                    self.comments()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 405
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,35,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 403
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
                    if la_ == 1:
                        localctx = RulepadGrammarParser.FunctionExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_functionExpression)
                        self.state = 397
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 398
                        localctx.op = self.binary()
                        self.state = 399
                        localctx.right = self.functionExpression(4)
                        pass

                    elif la_ == 2:
                        localctx = RulepadGrammarParser.FunctionExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_functionExpression)
                        self.state = 401
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 402
                        self.match(RulepadGrammarParser.SPACE)
                        pass

             
                self.state = 407
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,35,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AbstractFunctionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AbstractFunctions(self):
            return self.getToken(RulepadGrammarParser.AbstractFunctions, 0)

        def abstractFunctionCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AbstractFunctionConditionContext,0)


        def abstractFunctionOf(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AbstractFunctionOfContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_abstractFunctions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbstractFunctions" ):
                listener.enterAbstractFunctions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbstractFunctions" ):
                listener.exitAbstractFunctions(self)




    def abstractFunctions(self):

        localctx = RulepadGrammarParser.AbstractFunctionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_abstractFunctions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 408
            self.match(RulepadGrammarParser.AbstractFunctions)
            self.state = 410
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.state = 409
                self.abstractFunctionCondition()


            self.state = 413
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
            if la_ == 1:
                self.state = 412
                self.abstractFunctionOf()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AbstractFunctionOfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def of(self):
            return self.getTypedRuleContext(RulepadGrammarParser.OfContext,0)


        def classes(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ClassesContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_abstractFunctionOf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbstractFunctionOf" ):
                listener.enterAbstractFunctionOf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbstractFunctionOf" ):
                listener.exitAbstractFunctionOf(self)




    def abstractFunctionOf(self):

        localctx = RulepadGrammarParser.AbstractFunctionOfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_abstractFunctionOf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 415
            self.of()
            self.state = 416
            self.classes()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AbstractFunctionConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withWord(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WithWordContext,0)


        def abstractFunctionExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AbstractFunctionExpressionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_abstractFunctionCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbstractFunctionCondition" ):
                listener.enterAbstractFunctionCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbstractFunctionCondition" ):
                listener.exitAbstractFunctionCondition(self)




    def abstractFunctionCondition(self):

        localctx = RulepadGrammarParser.AbstractFunctionConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_abstractFunctionCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 418
            self.withWord()
            self.state = 419
            self.abstractFunctionExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AbstractFunctionExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # AbstractFunctionExpressionContext
            self.op = None # BinaryContext
            self.right = None # AbstractFunctionExpressionContext

        def LPAREN(self):
            return self.getToken(RulepadGrammarParser.LPAREN, 0)

        def abstractFunctionExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulepadGrammarParser.AbstractFunctionExpressionContext)
            else:
                return self.getTypedRuleContext(RulepadGrammarParser.AbstractFunctionExpressionContext,i)


        def RPAREN(self):
            return self.getToken(RulepadGrammarParser.RPAREN, 0)

        def annotations(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AnnotationsContext,0)


        def specifiers(self):
            return self.getTypedRuleContext(RulepadGrammarParser.SpecifiersContext,0)


        def visibilities(self):
            return self.getTypedRuleContext(RulepadGrammarParser.VisibilitiesContext,0)


        def types(self):
            return self.getTypedRuleContext(RulepadGrammarParser.TypesContext,0)


        def names(self):
            return self.getTypedRuleContext(RulepadGrammarParser.NamesContext,0)


        def parameters(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ParametersContext,0)


        def binary(self):
            return self.getTypedRuleContext(RulepadGrammarParser.BinaryContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_abstractFunctionExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbstractFunctionExpression" ):
                listener.enterAbstractFunctionExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbstractFunctionExpression" ):
                listener.exitAbstractFunctionExpression(self)



    def abstractFunctionExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RulepadGrammarParser.AbstractFunctionExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 66
        self.enterRecursionRule(localctx, 66, self.RULE_abstractFunctionExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 434
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.LPAREN]:
                self.state = 422
                self.match(RulepadGrammarParser.LPAREN)
                self.state = 423
                self.abstractFunctionExpression(0)
                self.state = 424
                self.match(RulepadGrammarParser.RPAREN)
                pass
            elif token in [RulepadGrammarParser.NAME, RulepadGrammarParser.ANNOTATION, RulepadGrammarParser.PARAMETER, RulepadGrammarParser.TYPES, RulepadGrammarParser.SPECIFIER, RulepadGrammarParser.VISIBILITY]:
                self.state = 432
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RulepadGrammarParser.ANNOTATION]:
                    self.state = 426
                    self.annotations()
                    pass
                elif token in [RulepadGrammarParser.SPECIFIER]:
                    self.state = 427
                    self.specifiers()
                    pass
                elif token in [RulepadGrammarParser.VISIBILITY]:
                    self.state = 428
                    self.visibilities()
                    pass
                elif token in [RulepadGrammarParser.TYPES]:
                    self.state = 429
                    self.types()
                    pass
                elif token in [RulepadGrammarParser.NAME]:
                    self.state = 430
                    self.names()
                    pass
                elif token in [RulepadGrammarParser.PARAMETER]:
                    self.state = 431
                    self.parameters()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 444
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,41,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 442
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
                    if la_ == 1:
                        localctx = RulepadGrammarParser.AbstractFunctionExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_abstractFunctionExpression)
                        self.state = 436
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 437
                        localctx.op = self.binary()
                        self.state = 438
                        localctx.right = self.abstractFunctionExpression(4)
                        pass

                    elif la_ == 2:
                        localctx = RulepadGrammarParser.AbstractFunctionExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_abstractFunctionExpression)
                        self.state = 440
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 441
                        self.match(RulepadGrammarParser.SPACE)
                        pass

             
                self.state = 446
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,41,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ConstructorsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSTRUCTOR(self):
            return self.getToken(RulepadGrammarParser.CONSTRUCTOR, 0)

        def constructorCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ConstructorConditionContext,0)


        def constructorOf(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ConstructorOfContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_constructors

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstructors" ):
                listener.enterConstructors(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstructors" ):
                listener.exitConstructors(self)




    def constructors(self):

        localctx = RulepadGrammarParser.ConstructorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_constructors)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 447
            self.match(RulepadGrammarParser.CONSTRUCTOR)
            self.state = 449
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                self.state = 448
                self.constructorCondition()


            self.state = 452
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                self.state = 451
                self.constructorOf()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstructorOfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def of(self):
            return self.getTypedRuleContext(RulepadGrammarParser.OfContext,0)


        def classes(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ClassesContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_constructorOf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstructorOf" ):
                listener.enterConstructorOf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstructorOf" ):
                listener.exitConstructorOf(self)




    def constructorOf(self):

        localctx = RulepadGrammarParser.ConstructorOfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_constructorOf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 454
            self.of()
            self.state = 455
            self.classes()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstructorConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withWord(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WithWordContext,0)


        def constructorExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ConstructorExpressionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_constructorCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstructorCondition" ):
                listener.enterConstructorCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstructorCondition" ):
                listener.exitConstructorCondition(self)




    def constructorCondition(self):

        localctx = RulepadGrammarParser.ConstructorConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_constructorCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 457
            self.withWord()
            self.state = 458
            self.constructorExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstructorExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # ConstructorExpressionContext
            self.op = None # BinaryContext
            self.right = None # ConstructorExpressionContext

        def LPAREN(self):
            return self.getToken(RulepadGrammarParser.LPAREN, 0)

        def constructorExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulepadGrammarParser.ConstructorExpressionContext)
            else:
                return self.getTypedRuleContext(RulepadGrammarParser.ConstructorExpressionContext,i)


        def RPAREN(self):
            return self.getToken(RulepadGrammarParser.RPAREN, 0)

        def annotations(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AnnotationsContext,0)


        def specifiers(self):
            return self.getTypedRuleContext(RulepadGrammarParser.SpecifiersContext,0)


        def visibilities(self):
            return self.getTypedRuleContext(RulepadGrammarParser.VisibilitiesContext,0)


        def parameters(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ParametersContext,0)


        def returnValues(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ReturnValuesContext,0)


        def declarationStatements(self):
            return self.getTypedRuleContext(RulepadGrammarParser.DeclarationStatementsContext,0)


        def expressionStatements(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ExpressionStatementsContext,0)


        def comments(self):
            return self.getTypedRuleContext(RulepadGrammarParser.CommentsContext,0)


        def binary(self):
            return self.getTypedRuleContext(RulepadGrammarParser.BinaryContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_constructorExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstructorExpression" ):
                listener.enterConstructorExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstructorExpression" ):
                listener.exitConstructorExpression(self)



    def constructorExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RulepadGrammarParser.ConstructorExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 74
        self.enterRecursionRule(localctx, 74, self.RULE_constructorExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 475
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.LPAREN]:
                self.state = 461
                self.match(RulepadGrammarParser.LPAREN)
                self.state = 462
                self.constructorExpression(0)
                self.state = 463
                self.match(RulepadGrammarParser.RPAREN)
                pass
            elif token in [RulepadGrammarParser.T__0, RulepadGrammarParser.ANNOTATION, RulepadGrammarParser.PARAMETER, RulepadGrammarParser.SPECIFIER, RulepadGrammarParser.VISIBILITY, RulepadGrammarParser.ReturnValue, RulepadGrammarParser.DeclarationStatement, RulepadGrammarParser.ExpressionStatement]:
                self.state = 473
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RulepadGrammarParser.ANNOTATION]:
                    self.state = 465
                    self.annotations()
                    pass
                elif token in [RulepadGrammarParser.SPECIFIER]:
                    self.state = 466
                    self.specifiers()
                    pass
                elif token in [RulepadGrammarParser.VISIBILITY]:
                    self.state = 467
                    self.visibilities()
                    pass
                elif token in [RulepadGrammarParser.PARAMETER]:
                    self.state = 468
                    self.parameters()
                    pass
                elif token in [RulepadGrammarParser.ReturnValue]:
                    self.state = 469
                    self.returnValues()
                    pass
                elif token in [RulepadGrammarParser.DeclarationStatement]:
                    self.state = 470
                    self.declarationStatements()
                    pass
                elif token in [RulepadGrammarParser.ExpressionStatement]:
                    self.state = 471
                    self.expressionStatements()
                    pass
                elif token in [RulepadGrammarParser.T__0]:
                    self.state = 472
                    self.comments()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 485
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,47,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 483
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
                    if la_ == 1:
                        localctx = RulepadGrammarParser.ConstructorExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_constructorExpression)
                        self.state = 477
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 478
                        localctx.op = self.binary()
                        self.state = 479
                        localctx.right = self.constructorExpression(4)
                        pass

                    elif la_ == 2:
                        localctx = RulepadGrammarParser.ConstructorExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_constructorExpression)
                        self.state = 481
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 482
                        self.match(RulepadGrammarParser.SPACE)
                        pass

             
                self.state = 487
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,47,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARAMETER(self):
            return self.getToken(RulepadGrammarParser.PARAMETER, 0)

        def parameterCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ParameterConditionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameters" ):
                listener.enterParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameters" ):
                listener.exitParameters(self)




    def parameters(self):

        localctx = RulepadGrammarParser.ParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 488
            self.match(RulepadGrammarParser.PARAMETER)
            self.state = 490
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
            if la_ == 1:
                self.state = 489
                self.parameterCondition()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withWord(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WithWordContext,0)


        def parameterExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ParameterExpressionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_parameterCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterCondition" ):
                listener.enterParameterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterCondition" ):
                listener.exitParameterCondition(self)




    def parameterCondition(self):

        localctx = RulepadGrammarParser.ParameterConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_parameterCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 492
            self.withWord()
            self.state = 493
            self.parameterExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # ParameterExpressionContext
            self.op = None # BinaryContext
            self.right = None # ParameterExpressionContext

        def LPAREN(self):
            return self.getToken(RulepadGrammarParser.LPAREN, 0)

        def parameterExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulepadGrammarParser.ParameterExpressionContext)
            else:
                return self.getTypedRuleContext(RulepadGrammarParser.ParameterExpressionContext,i)


        def RPAREN(self):
            return self.getToken(RulepadGrammarParser.RPAREN, 0)

        def types(self):
            return self.getTypedRuleContext(RulepadGrammarParser.TypesContext,0)


        def names(self):
            return self.getTypedRuleContext(RulepadGrammarParser.NamesContext,0)


        def binary(self):
            return self.getTypedRuleContext(RulepadGrammarParser.BinaryContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_parameterExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterExpression" ):
                listener.enterParameterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterExpression" ):
                listener.exitParameterExpression(self)



    def parameterExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RulepadGrammarParser.ParameterExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 80
        self.enterRecursionRule(localctx, 80, self.RULE_parameterExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 504
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.LPAREN]:
                self.state = 496
                self.match(RulepadGrammarParser.LPAREN)
                self.state = 497
                self.parameterExpression(0)
                self.state = 498
                self.match(RulepadGrammarParser.RPAREN)
                pass
            elif token in [RulepadGrammarParser.NAME, RulepadGrammarParser.TYPES]:
                self.state = 502
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RulepadGrammarParser.TYPES]:
                    self.state = 500
                    self.types()
                    pass
                elif token in [RulepadGrammarParser.NAME]:
                    self.state = 501
                    self.names()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 514
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,52,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 512
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
                    if la_ == 1:
                        localctx = RulepadGrammarParser.ParameterExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_parameterExpression)
                        self.state = 506
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 507
                        localctx.op = self.binary()
                        self.state = 508
                        localctx.right = self.parameterExpression(4)
                        pass

                    elif la_ == 2:
                        localctx = RulepadGrammarParser.ParameterExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_parameterExpression)
                        self.state = 510
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 511
                        self.match(RulepadGrammarParser.SPACE)
                        pass

             
                self.state = 516
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,52,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPES(self):
            return self.getToken(RulepadGrammarParser.TYPES, 0)

        def typeCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.TypeConditionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_types

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypes" ):
                listener.enterTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypes" ):
                listener.exitTypes(self)




    def types(self):

        localctx = RulepadGrammarParser.TypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_types)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 517
            self.match(RulepadGrammarParser.TYPES)
            self.state = 519
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
            if la_ == 1:
                self.state = 518
                self.typeCondition()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def combinatorialWords(self):
            return self.getTypedRuleContext(RulepadGrammarParser.CombinatorialWordsContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def words(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WordsContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_typeCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeCondition" ):
                listener.enterTypeCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeCondition" ):
                listener.exitTypeCondition(self)




    def typeCondition(self):

        localctx = RulepadGrammarParser.TypeConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_typeCondition)
        try:
            self.state = 527
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 521
                self.combinatorialWords()
                self.state = 522
                self.match(RulepadGrammarParser.SPACE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 524
                self.words()
                self.state = 525
                self.match(RulepadGrammarParser.SPACE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SpecifiersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SPECIFIER(self):
            return self.getToken(RulepadGrammarParser.SPECIFIER, 0)

        def specifierCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.SpecifierConditionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_specifiers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpecifiers" ):
                listener.enterSpecifiers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpecifiers" ):
                listener.exitSpecifiers(self)




    def specifiers(self):

        localctx = RulepadGrammarParser.SpecifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_specifiers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 529
            self.match(RulepadGrammarParser.SPECIFIER)
            self.state = 531
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
            if la_ == 1:
                self.state = 530
                self.specifierCondition()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SpecifierConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def words(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WordsContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_specifierCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpecifierCondition" ):
                listener.enterSpecifierCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpecifierCondition" ):
                listener.exitSpecifierCondition(self)




    def specifierCondition(self):

        localctx = RulepadGrammarParser.SpecifierConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_specifierCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 533
            self.words()
            self.state = 534
            self.match(RulepadGrammarParser.SPACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilitiesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VISIBILITY(self):
            return self.getToken(RulepadGrammarParser.VISIBILITY, 0)

        def visibilityCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.VisibilityConditionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_visibilities

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisibilities" ):
                listener.enterVisibilities(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisibilities" ):
                listener.exitVisibilities(self)




    def visibilities(self):

        localctx = RulepadGrammarParser.VisibilitiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_visibilities)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 536
            self.match(RulepadGrammarParser.VISIBILITY)
            self.state = 538
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
            if la_ == 1:
                self.state = 537
                self.visibilityCondition()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilityConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def words(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WordsContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_visibilityCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisibilityCondition" ):
                listener.enterVisibilityCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisibilityCondition" ):
                listener.exitVisibilityCondition(self)




    def visibilityCondition(self):

        localctx = RulepadGrammarParser.VisibilityConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_visibilityCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 540
            self.words()
            self.state = 541
            self.match(RulepadGrammarParser.SPACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnValuesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ReturnValue(self):
            return self.getToken(RulepadGrammarParser.ReturnValue, 0)

        def returnValueCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ReturnValueConditionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_returnValues

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnValues" ):
                listener.enterReturnValues(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnValues" ):
                listener.exitReturnValues(self)




    def returnValues(self):

        localctx = RulepadGrammarParser.ReturnValuesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_returnValues)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 543
            self.match(RulepadGrammarParser.ReturnValue)
            self.state = 545
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
            if la_ == 1:
                self.state = 544
                self.returnValueCondition()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnValueConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def combinatorialWords(self):
            return self.getTypedRuleContext(RulepadGrammarParser.CombinatorialWordsContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_returnValueCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnValueCondition" ):
                listener.enterReturnValueCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnValueCondition" ):
                listener.exitReturnValueCondition(self)




    def returnValueCondition(self):

        localctx = RulepadGrammarParser.ReturnValueConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_returnValueCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 547
            self.combinatorialWords()
            self.state = 548
            self.match(RulepadGrammarParser.SPACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationStatementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DeclarationStatement(self):
            return self.getToken(RulepadGrammarParser.DeclarationStatement, 0)

        def declarationStatementCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.DeclarationStatementConditionContext,0)


        def declarationStatementOf(self):
            return self.getTypedRuleContext(RulepadGrammarParser.DeclarationStatementOfContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_declarationStatements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarationStatements" ):
                listener.enterDeclarationStatements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarationStatements" ):
                listener.exitDeclarationStatements(self)




    def declarationStatements(self):

        localctx = RulepadGrammarParser.DeclarationStatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_declarationStatements)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 550
            self.match(RulepadGrammarParser.DeclarationStatement)
            self.state = 552
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
            if la_ == 1:
                self.state = 551
                self.declarationStatementCondition()


            self.state = 555
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
            if la_ == 1:
                self.state = 554
                self.declarationStatementOf()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationStatementOfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def of(self):
            return self.getTypedRuleContext(RulepadGrammarParser.OfContext,0)


        def classes(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ClassesContext,0)


        def functions(self):
            return self.getTypedRuleContext(RulepadGrammarParser.FunctionsContext,0)


        def constructors(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ConstructorsContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_declarationStatementOf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarationStatementOf" ):
                listener.enterDeclarationStatementOf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarationStatementOf" ):
                listener.exitDeclarationStatementOf(self)




    def declarationStatementOf(self):

        localctx = RulepadGrammarParser.DeclarationStatementOfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_declarationStatementOf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 557
            self.of()
            self.state = 561
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.CLASSES]:
                self.state = 558
                self.classes()
                pass
            elif token in [RulepadGrammarParser.FUNCTION]:
                self.state = 559
                self.functions()
                pass
            elif token in [RulepadGrammarParser.CONSTRUCTOR]:
                self.state = 560
                self.constructors()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationStatementConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withWord(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WithWordContext,0)


        def declarationStatementExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.DeclarationStatementExpressionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_declarationStatementCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarationStatementCondition" ):
                listener.enterDeclarationStatementCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarationStatementCondition" ):
                listener.exitDeclarationStatementCondition(self)




    def declarationStatementCondition(self):

        localctx = RulepadGrammarParser.DeclarationStatementConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_declarationStatementCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 563
            self.withWord()
            self.state = 564
            self.declarationStatementExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationStatementExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # DeclarationStatementExpressionContext
            self.op = None # BinaryContext
            self.right = None # DeclarationStatementExpressionContext

        def LPAREN(self):
            return self.getToken(RulepadGrammarParser.LPAREN, 0)

        def declarationStatementExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulepadGrammarParser.DeclarationStatementExpressionContext)
            else:
                return self.getTypedRuleContext(RulepadGrammarParser.DeclarationStatementExpressionContext,i)


        def RPAREN(self):
            return self.getToken(RulepadGrammarParser.RPAREN, 0)

        def annotations(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AnnotationsContext,0)


        def specifiers(self):
            return self.getTypedRuleContext(RulepadGrammarParser.SpecifiersContext,0)


        def visibilities(self):
            return self.getTypedRuleContext(RulepadGrammarParser.VisibilitiesContext,0)


        def types(self):
            return self.getTypedRuleContext(RulepadGrammarParser.TypesContext,0)


        def names(self):
            return self.getTypedRuleContext(RulepadGrammarParser.NamesContext,0)


        def initialValues(self):
            return self.getTypedRuleContext(RulepadGrammarParser.InitialValuesContext,0)


        def comments(self):
            return self.getTypedRuleContext(RulepadGrammarParser.CommentsContext,0)


        def binary(self):
            return self.getTypedRuleContext(RulepadGrammarParser.BinaryContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_declarationStatementExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarationStatementExpression" ):
                listener.enterDeclarationStatementExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarationStatementExpression" ):
                listener.exitDeclarationStatementExpression(self)



    def declarationStatementExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RulepadGrammarParser.DeclarationStatementExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 104
        self.enterRecursionRule(localctx, 104, self.RULE_declarationStatementExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 580
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.LPAREN]:
                self.state = 567
                self.match(RulepadGrammarParser.LPAREN)
                self.state = 568
                self.declarationStatementExpression(0)
                self.state = 569
                self.match(RulepadGrammarParser.RPAREN)
                pass
            elif token in [RulepadGrammarParser.T__0, RulepadGrammarParser.NAME, RulepadGrammarParser.ANNOTATION, RulepadGrammarParser.TYPES, RulepadGrammarParser.SPECIFIER, RulepadGrammarParser.VISIBILITY, RulepadGrammarParser.InitialValue]:
                self.state = 578
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RulepadGrammarParser.ANNOTATION]:
                    self.state = 571
                    self.annotations()
                    pass
                elif token in [RulepadGrammarParser.SPECIFIER]:
                    self.state = 572
                    self.specifiers()
                    pass
                elif token in [RulepadGrammarParser.VISIBILITY]:
                    self.state = 573
                    self.visibilities()
                    pass
                elif token in [RulepadGrammarParser.TYPES]:
                    self.state = 574
                    self.types()
                    pass
                elif token in [RulepadGrammarParser.NAME]:
                    self.state = 575
                    self.names()
                    pass
                elif token in [RulepadGrammarParser.InitialValue]:
                    self.state = 576
                    self.initialValues()
                    pass
                elif token in [RulepadGrammarParser.T__0]:
                    self.state = 577
                    self.comments()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 590
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,64,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 588
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,63,self._ctx)
                    if la_ == 1:
                        localctx = RulepadGrammarParser.DeclarationStatementExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_declarationStatementExpression)
                        self.state = 582
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 583
                        localctx.op = self.binary()
                        self.state = 584
                        localctx.right = self.declarationStatementExpression(4)
                        pass

                    elif la_ == 2:
                        localctx = RulepadGrammarParser.DeclarationStatementExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_declarationStatementExpression)
                        self.state = 586
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 587
                        self.match(RulepadGrammarParser.SPACE)
                        pass

             
                self.state = 592
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,64,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ExpressionStatementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ExpressionStatement(self):
            return self.getToken(RulepadGrammarParser.ExpressionStatement, 0)

        def expressionStatementCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ExpressionStatementConditionContext,0)


        def expressionStatementOf(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ExpressionStatementOfContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_expressionStatements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionStatements" ):
                listener.enterExpressionStatements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionStatements" ):
                listener.exitExpressionStatements(self)




    def expressionStatements(self):

        localctx = RulepadGrammarParser.ExpressionStatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_expressionStatements)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 593
            self.match(RulepadGrammarParser.ExpressionStatement)
            self.state = 595
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,65,self._ctx)
            if la_ == 1:
                self.state = 594
                self.expressionStatementCondition()


            self.state = 598
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
            if la_ == 1:
                self.state = 597
                self.expressionStatementOf()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionStatementOfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def of(self):
            return self.getTypedRuleContext(RulepadGrammarParser.OfContext,0)


        def functions(self):
            return self.getTypedRuleContext(RulepadGrammarParser.FunctionsContext,0)


        def constructors(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ConstructorsContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_expressionStatementOf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionStatementOf" ):
                listener.enterExpressionStatementOf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionStatementOf" ):
                listener.exitExpressionStatementOf(self)




    def expressionStatementOf(self):

        localctx = RulepadGrammarParser.ExpressionStatementOfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_expressionStatementOf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 600
            self.of()
            self.state = 604
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                self.state = 601
                self.functions()
                pass

            elif la_ == 2:
                self.state = 602
                self.constructors()
                pass

            elif la_ == 3:
                self.state = 603
                self.constructors()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionStatementConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withWord(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WithWordContext,0)


        def expressionStatementExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ExpressionStatementExpressionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_expressionStatementCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionStatementCondition" ):
                listener.enterExpressionStatementCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionStatementCondition" ):
                listener.exitExpressionStatementCondition(self)




    def expressionStatementCondition(self):

        localctx = RulepadGrammarParser.ExpressionStatementConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_expressionStatementCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 606
            self.withWord()
            self.state = 607
            self.expressionStatementExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionStatementExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # ExpressionStatementExpressionContext
            self.op = None # BinaryContext
            self.right = None # ExpressionStatementExpressionContext

        def LPAREN(self):
            return self.getToken(RulepadGrammarParser.LPAREN, 0)

        def expressionStatementExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulepadGrammarParser.ExpressionStatementExpressionContext)
            else:
                return self.getTypedRuleContext(RulepadGrammarParser.ExpressionStatementExpressionContext,i)


        def RPAREN(self):
            return self.getToken(RulepadGrammarParser.RPAREN, 0)

        def comments(self):
            return self.getTypedRuleContext(RulepadGrammarParser.CommentsContext,0)


        def value(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ValueContext,0)


        def binary(self):
            return self.getTypedRuleContext(RulepadGrammarParser.BinaryContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_expressionStatementExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionStatementExpression" ):
                listener.enterExpressionStatementExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionStatementExpression" ):
                listener.exitExpressionStatementExpression(self)



    def expressionStatementExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RulepadGrammarParser.ExpressionStatementExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 112
        self.enterRecursionRule(localctx, 112, self.RULE_expressionStatementExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 618
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.LPAREN]:
                self.state = 610
                self.match(RulepadGrammarParser.LPAREN)
                self.state = 611
                self.expressionStatementExpression(0)
                self.state = 612
                self.match(RulepadGrammarParser.RPAREN)
                pass
            elif token in [RulepadGrammarParser.T__0, RulepadGrammarParser.VALUE]:
                self.state = 616
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RulepadGrammarParser.T__0]:
                    self.state = 614
                    self.comments()
                    pass
                elif token in [RulepadGrammarParser.VALUE]:
                    self.state = 615
                    self.value()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 628
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,71,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 626
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
                    if la_ == 1:
                        localctx = RulepadGrammarParser.ExpressionStatementExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expressionStatementExpression)
                        self.state = 620
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 621
                        localctx.op = self.binary()
                        self.state = 622
                        localctx.right = self.expressionStatementExpression(4)
                        pass

                    elif la_ == 2:
                        localctx = RulepadGrammarParser.ExpressionStatementExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expressionStatementExpression)
                        self.state = 624
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 625
                        self.match(RulepadGrammarParser.SPACE)
                        pass

             
                self.state = 630
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,71,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VALUE(self):
            return self.getToken(RulepadGrammarParser.VALUE, 0)

        def valueCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ValueConditionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValue" ):
                listener.enterValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValue" ):
                listener.exitValue(self)




    def value(self):

        localctx = RulepadGrammarParser.ValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 631
            self.match(RulepadGrammarParser.VALUE)
            self.state = 633
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
            if la_ == 1:
                self.state = 632
                self.valueCondition()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def combinatorialWords(self):
            return self.getTypedRuleContext(RulepadGrammarParser.CombinatorialWordsContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_valueCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValueCondition" ):
                listener.enterValueCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValueCondition" ):
                listener.exitValueCondition(self)




    def valueCondition(self):

        localctx = RulepadGrammarParser.ValueConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_valueCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 635
            self.combinatorialWords()
            self.state = 636
            self.match(RulepadGrammarParser.SPACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InitialValuesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def InitialValue(self):
            return self.getToken(RulepadGrammarParser.InitialValue, 0)

        def initialValueCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.InitialValueConditionContext,0)


        def initialValueOf(self):
            return self.getTypedRuleContext(RulepadGrammarParser.InitialValueOfContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_initialValues

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitialValues" ):
                listener.enterInitialValues(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitialValues" ):
                listener.exitInitialValues(self)




    def initialValues(self):

        localctx = RulepadGrammarParser.InitialValuesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_initialValues)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 638
            self.match(RulepadGrammarParser.InitialValue)
            self.state = 640
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
            if la_ == 1:
                self.state = 639
                self.initialValueCondition()


            self.state = 643
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
            if la_ == 1:
                self.state = 642
                self.initialValueOf()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InitialValueOfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def of(self):
            return self.getTypedRuleContext(RulepadGrammarParser.OfContext,0)


        def declarationStatements(self):
            return self.getTypedRuleContext(RulepadGrammarParser.DeclarationStatementsContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_initialValueOf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitialValueOf" ):
                listener.enterInitialValueOf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitialValueOf" ):
                listener.exitInitialValueOf(self)




    def initialValueOf(self):

        localctx = RulepadGrammarParser.InitialValueOfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_initialValueOf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 645
            self.of()
            self.state = 646
            self.declarationStatements()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InitialValueConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def combinatorialWords(self):
            return self.getTypedRuleContext(RulepadGrammarParser.CombinatorialWordsContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_initialValueCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitialValueCondition" ):
                listener.enterInitialValueCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitialValueCondition" ):
                listener.exitInitialValueCondition(self)




    def initialValueCondition(self):

        localctx = RulepadGrammarParser.InitialValueConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_initialValueCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 648
            self.combinatorialWords()
            self.state = 649
            self.match(RulepadGrammarParser.SPACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLASSES(self):
            return self.getToken(RulepadGrammarParser.CLASSES, 0)

        def classCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ClassConditionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_classes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClasses" ):
                listener.enterClasses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClasses" ):
                listener.exitClasses(self)




    def classes(self):

        localctx = RulepadGrammarParser.ClassesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_classes)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 651
            self.match(RulepadGrammarParser.CLASSES)
            self.state = 653
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
            if la_ == 1:
                self.state = 652
                self.classCondition()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withWord(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WithWordContext,0)


        def classExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ClassExpressionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_classCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassCondition" ):
                listener.enterClassCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassCondition" ):
                listener.exitClassCondition(self)




    def classCondition(self):

        localctx = RulepadGrammarParser.ClassConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_classCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 655
            self.withWord()
            self.state = 656
            self.classExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # ClassExpressionContext
            self.op = None # BinaryContext
            self.right = None # ClassExpressionContext

        def LPAREN(self):
            return self.getToken(RulepadGrammarParser.LPAREN, 0)

        def classExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulepadGrammarParser.ClassExpressionContext)
            else:
                return self.getTypedRuleContext(RulepadGrammarParser.ClassExpressionContext,i)


        def RPAREN(self):
            return self.getToken(RulepadGrammarParser.RPAREN, 0)

        def annotations(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AnnotationsContext,0)


        def specifiers(self):
            return self.getTypedRuleContext(RulepadGrammarParser.SpecifiersContext,0)


        def visibilities(self):
            return self.getTypedRuleContext(RulepadGrammarParser.VisibilitiesContext,0)


        def names(self):
            return self.getTypedRuleContext(RulepadGrammarParser.NamesContext,0)


        def extensions(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ExtensionsContext,0)


        def implementations(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ImplementationsContext,0)


        def functions(self):
            return self.getTypedRuleContext(RulepadGrammarParser.FunctionsContext,0)


        def abstractFunctions(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AbstractFunctionsContext,0)


        def constructors(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ConstructorsContext,0)


        def declarationStatements(self):
            return self.getTypedRuleContext(RulepadGrammarParser.DeclarationStatementsContext,0)


        def returnValues(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ReturnValuesContext,0)


        def comments(self):
            return self.getTypedRuleContext(RulepadGrammarParser.CommentsContext,0)


        def subclasses(self):
            return self.getTypedRuleContext(RulepadGrammarParser.SubclassesContext,0)


        def binary(self):
            return self.getTypedRuleContext(RulepadGrammarParser.BinaryContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_classExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassExpression" ):
                listener.enterClassExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassExpression" ):
                listener.exitClassExpression(self)



    def classExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RulepadGrammarParser.ClassExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 128
        self.enterRecursionRule(localctx, 128, self.RULE_classExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 678
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RulepadGrammarParser.LPAREN]:
                self.state = 659
                self.match(RulepadGrammarParser.LPAREN)
                self.state = 660
                self.classExpression(0)
                self.state = 661
                self.match(RulepadGrammarParser.RPAREN)
                pass
            elif token in [RulepadGrammarParser.T__0, RulepadGrammarParser.NAME, RulepadGrammarParser.ANNOTATION, RulepadGrammarParser.EXTENSION, RulepadGrammarParser.IMPLEMENTATION, RulepadGrammarParser.FUNCTION, RulepadGrammarParser.AbstractFunctions, RulepadGrammarParser.CONSTRUCTOR, RulepadGrammarParser.SPECIFIER, RulepadGrammarParser.VISIBILITY, RulepadGrammarParser.ReturnValue, RulepadGrammarParser.DeclarationStatement, RulepadGrammarParser.SUBCLASSES]:
                self.state = 676
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RulepadGrammarParser.ANNOTATION]:
                    self.state = 663
                    self.annotations()
                    pass
                elif token in [RulepadGrammarParser.SPECIFIER]:
                    self.state = 664
                    self.specifiers()
                    pass
                elif token in [RulepadGrammarParser.VISIBILITY]:
                    self.state = 665
                    self.visibilities()
                    pass
                elif token in [RulepadGrammarParser.NAME]:
                    self.state = 666
                    self.names()
                    pass
                elif token in [RulepadGrammarParser.EXTENSION]:
                    self.state = 667
                    self.extensions()
                    pass
                elif token in [RulepadGrammarParser.IMPLEMENTATION]:
                    self.state = 668
                    self.implementations()
                    pass
                elif token in [RulepadGrammarParser.FUNCTION]:
                    self.state = 669
                    self.functions()
                    pass
                elif token in [RulepadGrammarParser.AbstractFunctions]:
                    self.state = 670
                    self.abstractFunctions()
                    pass
                elif token in [RulepadGrammarParser.CONSTRUCTOR]:
                    self.state = 671
                    self.constructors()
                    pass
                elif token in [RulepadGrammarParser.DeclarationStatement]:
                    self.state = 672
                    self.declarationStatements()
                    pass
                elif token in [RulepadGrammarParser.ReturnValue]:
                    self.state = 673
                    self.returnValues()
                    pass
                elif token in [RulepadGrammarParser.T__0]:
                    self.state = 674
                    self.comments()
                    pass
                elif token in [RulepadGrammarParser.SUBCLASSES]:
                    self.state = 675
                    self.subclasses()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 688
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,79,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 686
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
                    if la_ == 1:
                        localctx = RulepadGrammarParser.ClassExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_classExpression)
                        self.state = 680
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 681
                        localctx.op = self.binary()
                        self.state = 682
                        localctx.right = self.classExpression(4)
                        pass

                    elif la_ == 2:
                        localctx = RulepadGrammarParser.ClassExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_classExpression)
                        self.state = 684
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 685
                        self.match(RulepadGrammarParser.SPACE)
                        pass

             
                self.state = 690
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,79,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class SubclassesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBCLASSES(self):
            return self.getToken(RulepadGrammarParser.SUBCLASSES, 0)

        def subclassCondition(self):
            return self.getTypedRuleContext(RulepadGrammarParser.SubclassConditionContext,0)


        def subclassOf(self):
            return self.getTypedRuleContext(RulepadGrammarParser.SubclassOfContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_subclasses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubclasses" ):
                listener.enterSubclasses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubclasses" ):
                listener.exitSubclasses(self)




    def subclasses(self):

        localctx = RulepadGrammarParser.SubclassesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_subclasses)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 691
            self.match(RulepadGrammarParser.SUBCLASSES)
            self.state = 693
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
            if la_ == 1:
                self.state = 692
                self.subclassCondition()


            self.state = 696
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
            if la_ == 1:
                self.state = 695
                self.subclassOf()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubclassOfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def of(self):
            return self.getTypedRuleContext(RulepadGrammarParser.OfContext,0)


        def classes(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ClassesContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_subclassOf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubclassOf" ):
                listener.enterSubclassOf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubclassOf" ):
                listener.exitSubclassOf(self)




    def subclassOf(self):

        localctx = RulepadGrammarParser.SubclassOfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_subclassOf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 698
            self.of()
            self.state = 699
            self.classes()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubclassConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withWord(self):
            return self.getTypedRuleContext(RulepadGrammarParser.WithWordContext,0)


        def subclassExpression(self):
            return self.getTypedRuleContext(RulepadGrammarParser.SubclassExpressionContext,0)


        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_subclassCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubclassCondition" ):
                listener.enterSubclassCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubclassCondition" ):
                listener.exitSubclassCondition(self)




    def subclassCondition(self):

        localctx = RulepadGrammarParser.SubclassConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_subclassCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 701
            self.withWord()
            self.state = 702
            self.subclassExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubclassExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # SubclassExpressionContext
            self.op = None # BinaryContext
            self.right = None # SubclassExpressionContext

        def LPAREN(self):
            return self.getToken(RulepadGrammarParser.LPAREN, 0)

        def subclassExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulepadGrammarParser.SubclassExpressionContext)
            else:
                return self.getTypedRuleContext(RulepadGrammarParser.SubclassExpressionContext,i)


        def RPAREN(self):
            return self.getToken(RulepadGrammarParser.RPAREN, 0)

        def annotations(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AnnotationsContext,0)


        def specifiers(self):
            return self.getTypedRuleContext(RulepadGrammarParser.SpecifiersContext,0)


        def visibilities(self):
            return self.getTypedRuleContext(RulepadGrammarParser.VisibilitiesContext,0)


        def names(self):
            return self.getTypedRuleContext(RulepadGrammarParser.NamesContext,0)


        def extensions(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ExtensionsContext,0)


        def implementations(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ImplementationsContext,0)


        def functions(self):
            return self.getTypedRuleContext(RulepadGrammarParser.FunctionsContext,0)


        def subclasses(self):
            return self.getTypedRuleContext(RulepadGrammarParser.SubclassesContext,0)


        def abstractFunctions(self):
            return self.getTypedRuleContext(RulepadGrammarParser.AbstractFunctionsContext,0)


        def constructors(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ConstructorsContext,0)


        def declarationStatements(self):
            return self.getTypedRuleContext(RulepadGrammarParser.DeclarationStatementsContext,0)


        def returnValues(self):
            return self.getTypedRuleContext(RulepadGrammarParser.ReturnValuesContext,0)


        def comments(self):
            return self.getTypedRuleContext(RulepadGrammarParser.CommentsContext,0)


        def binary(self):
            return self.getTypedRuleContext(RulepadGrammarParser.BinaryContext,0)


        def SPACE(self):
            return self.getToken(RulepadGrammarParser.SPACE, 0)

        def getRuleIndex(self):
            return RulepadGrammarParser.RULE_subclassExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubclassExpression" ):
                listener.enterSubclassExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubclassExpression" ):
                listener.exitSubclassExpression(self)



    def subclassExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RulepadGrammarParser.SubclassExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 136
        self.enterRecursionRule(localctx, 136, self.RULE_subclassExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 725
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
            if la_ == 1:
                self.state = 705
                self.match(RulepadGrammarParser.LPAREN)
                self.state = 706
                self.subclassExpression(0)
                self.state = 707
                self.match(RulepadGrammarParser.RPAREN)
                pass

            elif la_ == 2:
                self.state = 723
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
                if la_ == 1:
                    self.state = 709
                    self.annotations()
                    pass

                elif la_ == 2:
                    self.state = 710
                    self.specifiers()
                    pass

                elif la_ == 3:
                    self.state = 711
                    self.visibilities()
                    pass

                elif la_ == 4:
                    self.state = 712
                    self.names()
                    pass

                elif la_ == 5:
                    self.state = 713
                    self.extensions()
                    pass

                elif la_ == 6:
                    self.state = 714
                    self.implementations()
                    pass

                elif la_ == 7:
                    self.state = 715
                    self.functions()
                    pass

                elif la_ == 8:
                    self.state = 716
                    self.subclasses()
                    pass

                elif la_ == 9:
                    pass

                elif la_ == 10:
                    self.state = 718
                    self.abstractFunctions()
                    pass

                elif la_ == 11:
                    self.state = 719
                    self.constructors()
                    pass

                elif la_ == 12:
                    self.state = 720
                    self.declarationStatements()
                    pass

                elif la_ == 13:
                    self.state = 721
                    self.returnValues()
                    pass

                elif la_ == 14:
                    self.state = 722
                    self.comments()
                    pass


                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 735
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,85,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 733
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
                    if la_ == 1:
                        localctx = RulepadGrammarParser.SubclassExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_subclassExpression)
                        self.state = 727
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 728
                        localctx.op = self.binary()
                        self.state = 729
                        localctx.right = self.subclassExpression(4)
                        pass

                    elif la_ == 2:
                        localctx = RulepadGrammarParser.SubclassExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_subclassExpression)
                        self.state = 731
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 732
                        self.match(RulepadGrammarParser.SPACE)
                        pass

             
                self.state = 737
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,85,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[21] = self.annotationExpression_sempred
        self._predicates[29] = self.functionExpression_sempred
        self._predicates[33] = self.abstractFunctionExpression_sempred
        self._predicates[37] = self.constructorExpression_sempred
        self._predicates[40] = self.parameterExpression_sempred
        self._predicates[52] = self.declarationStatementExpression_sempred
        self._predicates[56] = self.expressionStatementExpression_sempred
        self._predicates[64] = self.classExpression_sempred
        self._predicates[68] = self.subclassExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def annotationExpression_sempred(self, localctx:AnnotationExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 1)
         

    def functionExpression_sempred(self, localctx:FunctionExpressionContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 1)
         

    def abstractFunctionExpression_sempred(self, localctx:AbstractFunctionExpressionContext, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 1)
         

    def constructorExpression_sempred(self, localctx:ConstructorExpressionContext, predIndex:int):
            if predIndex == 6:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 1)
         

    def parameterExpression_sempred(self, localctx:ParameterExpressionContext, predIndex:int):
            if predIndex == 8:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 1)
         

    def declarationStatementExpression_sempred(self, localctx:DeclarationStatementExpressionContext, predIndex:int):
            if predIndex == 10:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 1)
         

    def expressionStatementExpression_sempred(self, localctx:ExpressionStatementExpressionContext, predIndex:int):
            if predIndex == 12:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 1)
         

    def classExpression_sempred(self, localctx:ClassExpressionContext, predIndex:int):
            if predIndex == 14:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 1)
         

    def subclassExpression_sempred(self, localctx:SubclassExpressionContext, predIndex:int):
            if predIndex == 16:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 17:
                return self.precpred(self._ctx, 1)
         




